<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibing</title>
    <style>
      :root {
        --bg: #0f1221;
        --fg: #e6e8f0;
        --muted: #9aa3b2;
        --accent: #8b5cf6;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--fg);
        background: radial-gradient(1200px 800px at 70% 10%, #1b1f3a, var(--bg));
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 28px 24px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        backdrop-filter: blur(6px);
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 28px;
        letter-spacing: 0.3px;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 18px;
      }
      #content {
        font-size: 18px;
        line-height: 1.6;
        background: rgba(255,255,255,0.04);
        border: 1px dashed rgba(255,255,255,0.12);
        border-radius: 12px;
        padding: 16px;
      }
      .footer {
        margin-top: 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: var(--muted);
      }
      .badge {
        display: inline-block;
        background: rgba(139, 92, 246, 0.18);
        color: #d4c2ff;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(139, 92, 246, 0.35);
        letter-spacing: 0.2px;
      }
    </style>
  </head>
  <body>
    <!-- BEGIN_EDITABLE -->
      <section id="content">
<section id="vibe2168" aria-label="Prism Atelier">
  <style>
    /* PRISM ATELIER — Edition 2168 */
    #vibe2168 {
      --bg0: #0b0e13;
      --bg1: #131a26;
      --ink: #eef3ff;
      --muted: #a6b2cc;
      --c1: #ff8aa3;
      --c2: #b79bff;
      --c3: #92ffe3;
      --c4: #ffd99a;

      position: relative;
      display: grid;
      place-items: center;
      min-height: 760px;
      padding: clamp(28px, 6vw, 100px);
      color: var(--ink);
      border-radius: 40px;
      overflow: hidden;
      isolation: isolate;
      background:
        radial-gradient(1200px 800px at 80% -20%, rgba(255,255,255,0.06), transparent 60%),
        radial-gradient(900px 800px at -10% 120%, rgba(255,255,255,0.04), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      box-shadow:
        0 80px 160px rgba(7, 10, 16, 0.65),
        inset 0 0 0 1px rgba(255,255,255,0.05),
        inset 0 18px 28px rgba(255,255,255,0.05);
    }

    /* Atmosphere */
    #vibe2168::before,
    #vibe2168::after {
      content: "";
      position: absolute; inset: -25%;
      pointer-events: none; z-index: 0;
    }
    #vibe2168::before {
      background:
        conic-gradient(from 0deg at 52% 48%,
          color-mix(in oklab, var(--c1), transparent 70%) 0 14%,
          transparent 14% 28%,
          color-mix(in oklab, var(--c2), transparent 76%) 28% 45%,
          transparent 45% 62%,
          color-mix(in oklab, var(--c3), transparent 74%) 62% 80%,
          transparent 80% 88%,
          color-mix(in oklab, var(--c4), transparent 76%) 88% 100%);
      filter: blur(40px) saturate(130%);
      mix-blend-mode: screen;
      opacity: .55;
      animation: swirl2168 120s linear infinite;
    }
    #vibe2168::after {
      background:
        radial-gradient(600px 420px at 60% 30%, rgba(255,255,255,0.06), transparent 60%),
        radial-gradient(700px 520px at 20% 90%, rgba(255,255,255,0.05), transparent 62%);
      mix-blend-mode: soft-light;
      opacity: .6;
    }
    @keyframes swirl2168 { to { transform: rotate(360deg) } }

    /* Canvas + film grain */
    #vibe2168 .field {
      position: absolute; inset: 0; z-index: 1; display: block;
    }
    #vibe2168 .grain {
      position: absolute; inset: 0; z-index: 1; pointer-events: none;
      opacity: .10; mix-blend-mode: screen;
      background-image:
        radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,0.35), transparent 40%),
        radial-gradient(1px 1px at 60% 40%, rgba(255,255,255,0.25), transparent 40%),
        radial-gradient(1px 1px at 80% 70%, rgba(255,255,255,0.25), transparent 40%),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,0.3), transparent 40%);
      animation: twinkle2168 14s ease-in-out infinite alternate;
    }
    @keyframes twinkle2168 {
      0%   { filter: brightness(110%) contrast(115%); transform: translateY(0); }
      100% { filter: brightness(125%) contrast(130%); transform: translateY(-0.6%); }
    }

    /* HUD */
    #vibe2168 .hud {
      position: relative; z-index: 2; width: min(1100px, 100%);
      display: grid; gap: clamp(14px, 2.2vw, 26px);
      place-items: center; text-align: center;
      transform: perspective(1200px) rotateX(var(--rx, 0deg)) rotateY(var(--ry, 0deg));
      transition: transform 220ms ease, filter 220ms ease;
    }
    #vibe2168 .crest {
      display: inline-flex; align-items: center; gap: 10px;
      padding: 10px 16px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--muted);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)) padding-box,
        linear-gradient(90deg, color-mix(in oklab, var(--c3), transparent 70%), color-mix(in oklab, var(--c2), transparent 70%)) border-box;
      backdrop-filter: blur(10px) saturate(140%);
      -webkit-backdrop-filter: blur(10px) saturate(140%);
      box-shadow: 0 18px 42px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
      font: 700 11px/1 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      letter-spacing: 0.16em; text-transform: uppercase;
    }
    #vibe2168 .spark {
      width: 10px; height: 10px; border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff 25%, var(--c1) 60%, transparent 62%);
      box-shadow: 0 0 0 5px color-mix(in oklab, var(--c1), transparent 82%), 0 0 18px var(--c1);
      animation: pulse2168 2.4s ease-in-out infinite;
    }
    @keyframes pulse2168 { 0%,100% {transform:scale(1);opacity:1} 50%{transform:scale(1.25);opacity:.8}}

    #vibe2168 .title {
      margin: 0;
      font: 900 clamp(58px, 12vw, 150px)/0.88 ui-serif, Georgia, "Times New Roman", Times, serif;
      letter-spacing: -0.02em;
      background: linear-gradient(180deg,
        color-mix(in oklab, var(--ink), #ffffff 10%),
        color-mix(in oklab, var(--c1), #ffffff 22%) 55%,
        color-mix(in oklab, var(--c2), #ffffff 24%));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 1px 0 rgba(255,255,255,0.25), 0 24px 60px rgba(0,0,0,0.45);
      position: relative;
    }
    #vibe2168 .title::after {
      content: "";
      position: absolute; left: 50%; transform: translateX(-50%); bottom: -18px;
      width: clamp(240px, 48vw, 680px); height: 12px; border-radius: 999px;
      background: linear-gradient(90deg, var(--c3), var(--c2), var(--c1));
      filter: blur(10px) saturate(150%); opacity: 0.9;
    }
    #vibe2168 .sub {
      margin: 0; color: var(--muted); max-width: 72ch;
      font: 400 clamp(16px, 2.2vw, 22px)/1.8 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Panel */
    #vibe2168 .panel {
      display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
    }
    #vibe2168 .chip {
      appearance: none; border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px; padding: 12px 16px; cursor: pointer; color: var(--ink);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)) padding-box,
        linear-gradient(90deg, color-mix(in oklab, var(--c3), transparent 70%), color-mix(in oklab, var(--c2), transparent 70%)) border-box;
      font: 700 12px/1 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      letter-spacing: .04em;
      transition: transform 160ms ease, filter 220ms ease, box-shadow 220ms ease, background 160ms ease;
      box-shadow: 0 14px 36px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
      backdrop-filter: blur(8px) saturate(140%); -webkit-backdrop-filter: blur(8px) saturate(140%);
    }
    #vibe2168 .chip:hover { transform: translateY(-1px); filter: saturate(118%); }
    #vibe2168 .chip:active { transform: translateY(0); }
    #vibe2168 .chip:focus-visible { outline: 2px solid color-mix(in oklab, var(--c2), white 12%); outline-offset: 2px; }

    /* Sliders */
    #vibe2168 .sliders {
      display: flex; flex-wrap: wrap; gap: 14px; justify-content: center; align-items: center;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.12); border-radius: 16px;
      padding: 10px 14px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.25);
      backdrop-filter: blur(8px) saturate(140%); -webkit-backdrop-filter: blur(8px) saturate(140%);
    }
    #vibe2168 .sliders label {
      font: 600 11px/1 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      letter-spacing: .12em; text-transform: uppercase; color: var(--muted);
      display: flex; align-items: center; gap: 10px;
    }
    #vibe2168 input[type="range"] { width: 160px; accent-color: var(--c2); }

    /* Meta */
    #vibe2168 .meta {
      display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 12px;
      width: min(920px, 100%); color: var(--muted);
      font: 400 12px/1.6 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    @media (max-width: 760px) {
      #vibe2168 .meta { grid-template-columns: 1fr; justify-items: center; text-align: center; }
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      #vibe2168::before { animation: none !important; }
      #vibe2168 .grain { animation: none !important; }
    }
  </style>

  <canvas class="field" aria-hidden="true"></canvas>
  <div class="grain" aria-hidden="true"></div>

  <div class="hud" role="region" aria-live="polite">
    <div class="crest"><span class="spark" aria-hidden="true"></span> Edition 2168 · Prism Atelier</div>
    <h1 class="title">PRISM</h1>
    <p class="sub">A kaleidoscopic sketchpad. Drag to paint with symmetry. S toggles spin · M mirrors · P palette · G glow · C clear.</p>

    <div class="panel">
      <button class="chip" data-act="palette" aria-label="Cycle palette">Palette: Velvet</button>
      <button class="chip" data-act="mirrors" aria-label="Change mirror count">Mirrors: 12</button>
      <button class="chip" data-act="spin" aria-label="Toggle auto-spin">Spin: On</button>
      <button class="chip" data-act="glow" aria-label="Toggle glow">Glow: On</button>
      <button class="chip" data-act="clear" aria-label="Clear canvas">Clear</button>
      <button class="chip" data-act="export" aria-label="Export image">Export</button>
      <button class="chip" data-act="hud" aria-label="Hide interface">Hide UI</button>
    </div>

    <div class="sliders" role="group" aria-label="Brush controls">
      <label>Width <input type="range" min="1" max="14" step="0.5" value="4" data-range="width" aria-label="Brush width"></label>
      <label>Fade <input type="range" min="0.02" max="0.18" step="0.005" value="0.07" data-range="fade" aria-label="Trail fade speed"></label>
    </div>

    <div class="meta">
      <span class="hint">Tip: Hold and swirl near the center for rosettes. Arrow keys tilt the stage. R recenters view.</span>
      <span id="last-updated">Last updated: 2026-01-24 13:27:42 EST</span>
    </div>
  </div>

  <script>
    (function () {
      const root = document.getElementById('vibe2168');
      const canvas = root.querySelector('.field');
      const ctx = canvas.getContext('2d');

      const btnPalette = root.querySelector('[data-act="palette"]');
      const btnMirrors = root.querySelector('[data-act="mirrors"]');
      const btnSpin    = root.querySelector('[data-act="spin"]');
      const btnGlow    = root.querySelector('[data-act="glow"]');
      const btnClear   = root.querySelector('[data-act="clear"]');
      const btnExport  = root.querySelector('[data-act="export"]');
      const btnHUD     = root.querySelector('[data-act="hud"]');
      const rangeWidth = root.querySelector('[data-range="width"]');
      const rangeFade  = root.querySelector('[data-range="fade"]');
      const last       = root.querySelector('#last-updated');

      // Timestamp
      try {
        last.textContent = 'Last updated: ' + new Date().toLocaleString(undefined, {
          year: 'numeric', month: 'short', day: '2-digit',
          hour: '2-digit', minute: '2-digit', second: '2-digit'
        });
      } catch {
        last.textContent = 'Last updated: ' + new Date().toString();
      }

      const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
      const TAU = Math.PI * 2;

      // Palettes
      const palettes = [
        {
          name: 'Velvet',
          bg0:'#0b0e13', bg1:'#131a26', ink:'#eef3ff', muted:'#a6b2cc',
          c1:'#ff8aa3', c2:'#b79bff', c3:'#92ffe3', c4:'#ffd99a',
          strokes:['#ff8aa3','#caa7ff','#a1ffe8','#ffd9a8','#a3c8ff']
        },
        {
          name: 'Citrus',
          bg0:'#0a1010', bg1:'#101e1a', ink:'#f5fff8', muted:'#b7d1c4',
          c1:'#ffb86b', c2:'#ffe36e', c3:'#8cffd2', c4:'#7bd6ff',
          strokes:['#ffb86b','#ffd36e','#7cffd2','#7bd6ff','#fff1a1']
        },
        {
          name: 'Aurora',
          bg0:'#0b0d17', bg1:'#10142a', ink:'#eef2ff', muted:'#a6b1d9',
          c1:'#9ad1ff', c2:'#b19cff', c3:'#8ff9d1', c4:'#ffc6a5',
          strokes:['#9ad1ff','#b19cff','#8ff9d1','#ffc6a5','#e7a1ff']
        },
        {
          name: 'Mono',
          bg0:'#0a0a0d', bg1:'#141419', ink:'#f3f4f6', muted:'#b8bcc8',
          c1:'#ffffff', c2:'#ddddee', c3:'#bbbbcc', c4:'#ffffff',
          strokes:['#ffffff','#ddddff','#ccccff','#eeeeff']
        }
      ];
      let paletteIndex = 0;

      function applyPalette(p) {
        root.style.setProperty('--bg0', p.bg0);
        root.style.setProperty('--bg1', p.bg1);
        root.style.setProperty('--ink', p.ink);
        root.style.setProperty('--muted', p.muted);
        root.style.setProperty('--c1', p.c1);
        root.style.setProperty('--c2', p.c2);
        root.style.setProperty('--c3', p.c3);
        root.style.setProperty('--c4', p.c4);
        btnPalette.textContent = 'Palette: ' + p.name;
        // Soft wipe to harmonize with palette
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgba(0,0,0,1)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
        clearCanvas(true);
      }
      applyPalette(palettes[paletteIndex]);

      // Scene state
      let W=1, H=1, CX=0.5, CY=0.5;
      let running = true;
      let mirrors = 12;
      let glow = true;
      let spin = true;
      let baseRot = 0;
      let brushW = parseFloat(rangeWidth.value);
      let fadeA = parseFloat(rangeFade.value);

      const pointer = { x:0.5, y:0.5, down:false };
      let prev = null;

      function resize() {
        const rect = root.getBoundingClientRect();
        W = Math.max(1, Math.floor(rect.width));
        H = Math.max(1, Math.floor(rect.height));
        canvas.width = W * DPR;
        canvas.height = H * DPR;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        CX = W/2; CY = H/2;
        clearCanvas(true);
      }

      function clearCanvas(hard=false) {
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        if (hard) {
          ctx.clearRect(0,0,W,H);
          // vignette base
          const g = ctx.createRadialGradient(CX, CY, 0, CX, CY, Math.max(W,H)*0.8);
          g.addColorStop(0, 'rgba(255,255,255,0.05)');
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.fillRect(0,0,W,H);
        }
        ctx.restore();
      }

      function pickColor() {
        const p = palettes[paletteIndex].strokes;
        return p[Math.floor(Math.random()*p.length)];
      }

      function transformPoint(x, y, ang, mirror=false) {
        let dx = x - CX, dy = y - CY;
        if (mirror) dx = -dx;
        const c = Math.cos(ang), s = Math.sin(ang);
        const rx = dx*c - dy*s, ry = dx*s + dy*c;
        return [CX + rx, CY + ry];
      }

      function strokeSegment(p0, p1, color) {
        ctx.save();
        ctx.globalCompositeOperation = glow ? 'lighter' : 'source-over';
        ctx.strokeStyle = color;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (let k=0; k<mirrors; k++) {
          const a = baseRot + k * TAU / mirrors;
          for (let m=0; m<2; m++) {
            const t0 = transformPoint(p0.x, p0.y, a, !!m);
            const t1 = transformPoint(p1.x, p1.y, a, !!m);

            const w = brushW * (1 + (m?0.0:0.06)) * (1 + (k%2 ? 0.04 : -0.02));
            ctx.lineWidth = Math.max(0.5, w);

            ctx.beginPath();
            ctx.moveTo(t0[0], t0[1]);
            ctx.lineTo(t1[0], t1[1]);
            ctx.stroke();

            // soft halo
            if (glow) {
              ctx.globalAlpha = 0.25;
              ctx.lineWidth = Math.max(0.5, w * 2.2);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
          }
        }
        ctx.restore();
      }

      // Autopainter (rosette)
      const auto = {
        theta: 0, phi: 0,
        r1: () => Math.min(W,H) * 0.34,
        r2: () => Math.min(W,H) * 0.18,
        col: pickColor(), t: 0
      };

      function tick(now) {
        if (!running) return;
        // fade
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(0,0,0,${fadeA})`;
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        if (spin) {
          baseRot += 0.0018;
          auto.theta += 0.011; auto.phi += 0.017;
          const x = CX + Math.cos(auto.theta) * auto.r1();
          const y = CY + Math.sin(auto.theta*1.2) * auto.r2();
          const p1 = { x, y };
          const p0 = auto.prev || p1;
          auto.t += 1;
          if (auto.t % 60 === 0) auto.col = pickColor();
          strokeSegment(p0, p1, auto.col);
          auto.prev = p1;
        }

        requestAnimationFrame(tick);
      }

      function setTilt(clientX, clientY){
        const rect = root.getBoundingClientRect();
        const px = clamp((clientX - rect.left) / rect.width, 0, 1);
        const py = clamp((clientY - rect.top) / rect.height, 0, 1);
        pointer.x = px; pointer.y = py;
        root.style.setProperty('--rx', ((0.5 - py) * 6).toFixed(2) + 'deg');
        root.style.setProperty('--ry', ((px - 0.5) * 8).toFixed(2) + 'deg');
      }

      // Interactions
      root.addEventListener('pointerdown', (e) => {
        pointer.down = true;
        const r = root.getBoundingClientRect();
        setTilt(e.clientX, e.clientY);
        prev = { x: e.clientX - r.left, y: e.clientY - r.top };
        auto.prev = null; // separate user stroke
        root.setPointerCapture?.(e.pointerId);
      });
      root.addEventListener('pointermove', (e) => {
        setTilt(e.clientX, e.clientY);
        if (!pointer.down) return;
        const r = root.getBoundingClientRect();
        const cur = { x: e.clientX - r.left, y: e.clientY - r.top };
        const color = pickColor();
        strokeSegment(prev || cur, cur, color);
        prev = cur;
      }, { passive: true });
      root.addEventListener('pointerup', (e) => {
        pointer.down = false;
        prev = null;
        root.releasePointerCapture?.(e.pointerId);
      });
      root.addEventListener('pointerleave', () => {
        pointer.down = false;
        root.style.setProperty('--rx', '0deg');
        root.style.setProperty('--ry', '0deg');
      }, { passive: true });

      // Controls
      function cyclePalette() {
        paletteIndex = (paletteIndex + 1) % palettes.length;
        applyPalette(palettes[paletteIndex]);
      }
      function cycleMirrors() {
        const options = [6, 8, 12, 16, 24];
        const idx = (options.indexOf(mirrors) + 1) % options.length;
        mirrors = options[idx];
        btnMirrors.textContent = 'Mirrors: ' + mirrors;
      }
      function toggleSpin() {
        spin = !spin; btnSpin.textContent = 'Spin: ' + (spin ? 'On' : 'Off');
      }
      function toggleGlow() {
        glow = !glow; btnGlow.textContent = 'Glow: ' + (glow ? 'On' : 'Off');
      }
      function clearAll() { clearCanvas(true); }
      function exportPNG() {
        const a = document.createElement('a');
        a.download = 'prism-' + Date.now() + '.png';
        a.href = canvas.toDataURL('image/png');
        a.click();
      }
      function toggleHUD() {
        const hud = root.querySelector('.hud');
        if (!hud) return;
        if (hud.style.opacity === '0') {
          hud.style.opacity = ''; hud.style.pointerEvents = '';
          btnHUD.textContent = 'Hide UI';
        } else {
          hud.style.opacity = '0'; hud.style.pointerEvents = 'none';
          setTimeout(()=>{ btnHUD.textContent = 'Show UI'; }, 50);
        }
      }

      btnPalette.addEventListener('click', () => { cyclePalette(); btnPalette.blur(); });
      btnMirrors.addEventListener('click', () => { cycleMirrors(); btnMirrors.blur(); });
      btnSpin.addEventListener('click', () => { toggleSpin(); btnSpin.blur(); });
      btnGlow.addEventListener('click', () => { toggleGlow(); btnGlow.blur(); });
      btnClear.addEventListener('click', () => { clearAll(); btnClear.blur(); });
      btnExport.addEventListener('click', () => { exportPNG(); btnExport.blur(); });
      btnHUD.addEventListener('click', () => { toggleHUD(); });

      rangeWidth.addEventListener('input', () => { brushW = parseFloat(rangeWidth.value); });
      rangeFade.addEventListener('input', () => { fadeA = parseFloat(rangeFade.value); });

      // Keyboard
      window.addEventListener('keydown', (e) => {
        const step = 0.02;
        if (e.key === 'ArrowLeft')  { pointer.x = clamp(pointer.x - step, 0, 1); const r = root.getBoundingClientRect(); setTilt(r.left + r.width * pointer.x, r.top + r.height * pointer.y); }
        if (e.key === 'ArrowRight') { pointer.x = clamp(pointer.x + step, 0, 1); const r = root.getBoundingClientRect(); setTilt(r.left + r.width * pointer.x, r.top + r.height * pointer.y); }
        if (e.key === 'ArrowUp')    { pointer.y = clamp(pointer.y - step, 0, 1); const r = root.getBoundingClientRect(); setTilt(r.left + r.width * pointer.x, r.top + r.height * pointer.y); }
        if (e.key === 'ArrowDown')  { pointer.y = clamp(pointer.y + step, 0, 1); const r = root.getBoundingClientRect(); setTilt(r.left + r.width * pointer.x, r.top + r.height * pointer.y); }
        if (e.key.toLowerCase() === 'p') cyclePalette();
        if (e.key.toLowerCase() === 'm') cycleMirrors();
        if (e.key.toLowerCase() === 's') toggleSpin();
        if (e.key.toLowerCase() === 'g') toggleGlow();
        if (e.key.toLowerCase() === 'c') clearAll();
        if (e.key.toLowerCase() === 'h') toggleHUD();
        if (e.key.toLowerCase() === 'r') { root.style.setProperty('--rx', '0deg'); root.style.setProperty('--ry', '0deg'); }
      });

      // Resize observer
      const ro = new ResizeObserver(resize);
      ro.observe(root);
      resize();

      // PRM
      const prm = window.matchMedia('(prefers-reduced-motion: reduce)');
      function applyPRM() {
        if (prm.matches) {
          spin = false;
          btnSpin.textContent = 'Spin: Off';
        }
      }
      prm.addEventListener?.('change', applyPRM);
      applyPRM();

      // Idle glide for tilt
      setInterval(() => {
        if (!running || pointer.down) return;
        const t = Date.now() * 0.00025;
        const nx = 0.5 + Math.sin(t * 1.3) * 0.16;
        const ny = 0.5 + Math.cos(t * 1.05) * 0.12;
        const rect = root.getBoundingClientRect();
        setTilt(rect.left + rect.width * nx, rect.top + rect.height * ny);
      }, 100);

      // Kickoff
      requestAnimationFrame(tick);
    })();
  </script>
</section>
      </section>
      <!-- END_EDITABLE -->
    <script>
      // Only show a local placeholder if the agent hasn't written a timestamp yet
      const el = document.getElementById('last-updated');
      if (el && (!el.textContent || el.textContent.includes('not yet'))) {
        const now = new Date();
        el.textContent = `Last updated: ${now.toLocaleString(undefined, { hour12: false })}`;
      }
    </script>
  </body>
  </html>


