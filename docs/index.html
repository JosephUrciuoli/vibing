<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibing</title>
    <style>
      :root {
        --bg: #0f1221;
        --fg: #e6e8f0;
        --muted: #9aa3b2;
        --accent: #8b5cf6;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--fg);
        background: radial-gradient(1200px 800px at 70% 10%, #1b1f3a, var(--bg));
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 28px 24px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        backdrop-filter: blur(6px);
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 28px;
        letter-spacing: 0.3px;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 18px;
      }
      #content {
        font-size: 18px;
        line-height: 1.6;
        background: rgba(255,255,255,0.04);
        border: 1px dashed rgba(255,255,255,0.12);
        border-radius: 12px;
        padding: 16px;
      }
      .footer {
        margin-top: 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: var(--muted);
      }
      .badge {
        display: inline-block;
        background: rgba(139, 92, 246, 0.18);
        color: #d4c2ff;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(139, 92, 246, 0.35);
        letter-spacing: 0.2px;
      }
    </style>
  </head>
  <body>
    <!-- BEGIN_EDITABLE -->
      <section id="content">
<section class="vibe2436 prism" role="region" aria-label="Prism Atelier — generative poster studio">
  <style>
    .vibe2436 {
      --r: 28px;
      --bg1: hsl(225 30% 10%);
      --bg2: hsl(220 25% 6%);
      --ink: 220 22% 94%;
      --muted: 220 12% 70%;
      --line: 220 16% 26%;
      --mx: 50%;
      --my: 50%;
      --h: 210;
      position: relative;
      padding: clamp(18px, 5.6vw, 64px);
      border-radius: var(--r);
      border: 1px solid hsl(var(--line));
      color: hsl(var(--ink));
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", Segoe UI, Roboto, "Helvetica Neue", Arial;
      background:
        radial-gradient(1200px 900px at var(--mx) var(--my), hsl(var(--h) 98% 60% / 0.16), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      box-shadow: 0 50px 140px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.06);
      overflow: hidden;
      isolation: isolate;
    }
    .vibe2436::before, .vibe2436::after {
      content: "";
      position: absolute; inset: -30%;
      pointer-events: none; filter: blur(80px) saturate(150%);
      background:
        conic-gradient(from 0deg at 60% 40%,
          hsl(calc(var(--h) + 0) 95% 60% / 0.00) 0deg,
          hsl(calc(var(--h) + 40) 95% 60% / 0.12) 90deg,
          hsl(calc(var(--h) + 140) 95% 60% / 0.10) 180deg,
          hsl(calc(var(--h) + 220) 95% 60% / 0.12) 270deg,
          transparent 360deg);
      mix-blend-mode: screen;
      animation: v2436_wash 30s linear infinite;
      z-index: 0;
    }
    .vibe2436::after { animation-direction: reverse; opacity: 0.7; }
    @keyframes v2436_wash { to { transform: rotate(360deg) scale(1.02); } }

    .vibe2436.light {
      --bg1: hsl(220 40% 98%);
      --bg2: hsl(220 42% 95%);
      --ink: 232 18% 12%;
      --muted: 232 12% 40%;
      --line: 232 22% 86%;
      box-shadow: 0 40px 120px rgba(25,35,75,0.16), inset 0 1px 0 #fff;
    }
    .vibe2436.light::before, .vibe2436.light::after { mix-blend-mode: multiply; opacity: 0.85; }

    .vibe2436 * { box-sizing: border-box; }

    /* Header */
    .vibe2436 .head {
      position: relative; z-index: 1;
      display: grid; gap: 10px; justify-items: center; text-align: center;
      margin-bottom: clamp(20px, 5vw, 36px);
    }
    .vibe2436 .eyebrow {
      display: inline-flex; align-items: center; gap: 10px; padding: 8px 12px;
      font-size: 11px; letter-spacing: 0.14em; text-transform: uppercase; color: hsl(var(--muted));
      border-radius: 999px; border: 1px solid hsl(var(--line));
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      backdrop-filter: blur(6px);
    }
    .vibe2436.light .eyebrow { background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.72)); }
    .vibe2436 .gem { width: 10px; height: 10px; border-radius: 4px;
      background: linear-gradient(135deg, hsl(var(--h) 92% 60%), hsl(calc(var(--h)+90) 92% 62%));
      box-shadow: 0 0 12px hsl(var(--h) 92% 58% / 0.6);
      animation: v2436_pulse 3s ease-in-out infinite;
    }
    @keyframes v2436_pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.25);} }

    .vibe2436 .title {
      margin: 0;
      font-size: clamp(44px, 9vw, 112px);
      line-height: 0.88;
      letter-spacing: -0.02em;
      background: linear-gradient(90deg,
        hsl(calc(var(--h)-20) 92% 64%),
        hsl(calc(var(--h)+10) 92% 60%),
        hsl(calc(var(--h)+120) 88% 62%));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      filter: drop-shadow(0 10px 24px rgba(0,0,0,0.12));
      text-wrap: balance;
      white-space: nowrap;
    }
    .vibe2436 .lede {
      margin: 2px 0 0;
      color: hsl(var(--muted));
      font-size: clamp(14px, 2vw, 18px);
      max-width: 70ch; text-wrap: pretty;
    }

    /* Stage */
    .vibe2436 .stage { position: relative; z-index: 1; display: grid; gap: 18px; justify-items: center; }

    .vibe2436 .poster-wrap {
      --rx: 0deg; --ry: 0deg;
      position: relative;
      width: min(86vw, 900px);
      aspect-ratio: 7 / 10;
      border-radius: 22px;
      border: 1px solid hsl(var(--line));
      overflow: hidden;
      transform: perspective(1200px) rotateX(var(--ry)) rotateY(var(--rx));
      transition: transform .15s ease-out, box-shadow .2s ease;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 30px 110px rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      background:
        radial-gradient(140% 100% at var(--mx) var(--my), rgba(255,255,255,0.18), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    }
    .vibe2436.light .poster-wrap {
      box-shadow: inset 0 1px 0 #fff, 0 26px 90px rgba(25,35,75,0.16);
      background:
        radial-gradient(140% 100% at var(--mx) var(--my), rgba(255,255,255,0.35), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.72));
    }

    .vibe2436 canvas.poster { position: absolute; inset: 0; display: block; width: 100%; height: 100%; }

    .vibe2436 .poster-wrap[data-grid="true"]::after {
      content: "";
      position: absolute; inset: 0; pointer-events: none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 32px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 32px);
      mix-blend-mode: overlay;
    }
    .vibe2436.light .poster-wrap[data-grid="true"]::after {
      background:
        repeating-linear-gradient(0deg, rgba(0,0,0,0.08) 0 1px, transparent 1px 32px),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.08) 0 1px, transparent 1px 32px);
      mix-blend-mode: multiply;
    }

    .vibe2436 .dock {
      display: grid; gap: 12px; grid-template-columns: repeat(6, minmax(0, 1fr));
      width: min(90vw, 920px);
    }
    @media (max-width: 880px) { .vibe2436 .dock { grid-template-columns: 1fr 1fr; } }

    .vibe2436 .control, .vibe2436 .select, .vibe2436 .btn {
      display: flex; align-items: center; justify-content: space-between; gap: 10px;
      padding: 12px 14px;
      border: 1px solid hsl(var(--line)); border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      color: hsl(var(--ink));
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 36px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.06);
    }
    .vibe2436.light .control, .vibe2436.light .select, .vibe2436.light .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.72));
      box-shadow: 0 12px 34px rgba(25,35,75,0.12), inset 0 1px 0 #fff;
      color: hsl(var(--ink));
    }
    .vibe2436 select {
      appearance: none; border: none; background: transparent; color: inherit; font: inherit; padding-right: 18px; cursor: pointer;
    }
    .vibe2436 input[type="range"] {
      appearance: none; inline-size: 52%; min-inline-size: 150px; block-size: 8px;
      background: rgba(255,255,255,0.12); border-radius: 999px; border: 1px solid hsl(var(--line));
    }
    .vibe2436.light input[type="range"] { background: rgba(0,0,0,0.08); }
    .vibe2436 input[type="range"]::-webkit-slider-thumb {
      appearance: none; width: 18px; height: 18px; border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff, hsl(var(--h) 92% 60%) 60%);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 6px 16px hsl(var(--h) 90% 55% / 0.35);
      cursor: pointer;
    }
    .vibe2436 input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border: none; border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff, hsl(var(--h) 92% 60%) 60%);
      box-shadow: 0 6px 16px hsl(var(--h) 90% 55% / 0.35); cursor: pointer;
    }
    .vibe2436 .btn {
      appearance: none; cursor: pointer; font-weight: 700; letter-spacing: 0.2px;
      transition: transform .15s ease, box-shadow .25s ease, background .25s ease;
      justify-content: center;
    }
    .vibe2436 .btn:hover { transform: translateY(-1px); }
    .vibe2436 .btn[aria-pressed="true"] {
      color: #0b0f18;
      background: linear-gradient(180deg, hsl(var(--h) 92% 64%), hsl(var(--h) 92% 56%));
      border-color: transparent;
      box-shadow: 0 14px 34px hsl(var(--h) 90% 55% / 0.42);
    }

    .vibe2436 .meta {
      margin-top: 14px; color: hsl(var(--muted)); font-size: 12px;
      display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;
      position: relative; z-index: 1;
    }
    .vibe2436 .meta a { color: inherit; text-decoration: underline dotted; text-underline-offset: 3px; }

    .vibe2436 .control:focus-within,
    .vibe2436 .select:focus-within,
    .vibe2436 .btn:focus-visible,
    .vibe2436 input[type="range"]:focus-visible,
    .vibe2436 select:focus-visible {
      outline: none; box-shadow: 0 0 0 3px hsl(var(--h) 90% 60% / 0.35);
    }
  </style>

  <div class="head" role="group" aria-label="Header">
    <span class="eyebrow"><i class="gem" aria-hidden="true"></i> Edition 2436 — Prism Atelier</span>
    <h1 class="title" aria-label="Prism Atelier">Live Poster Composer</h1>
    <p class="lede">Drag to tilt. Paint with beams and gradients. Make a poster that hums quietly.</p>
  </div>

  <div class="stage">
    <div class="poster-wrap" role="img" aria-label="Generative poster" data-grid="false">
      <canvas class="poster"></canvas>
    </div>

    <div class="dock" role="group" aria-label="Controls">
      <label class="select">Palette
        <select aria-label="Palette">
          <option value="prism" selected>Prism</option>
          <option value="flora">Flora</option>
          <option value="aqua">Aqua</option>
          <option value="ember">Ember</option>
          <option value="void">Void</option>
        </select>
      </label>

      <label class="control">Beams
        <input type="range" min="6" max="48" value="18" aria-label="Beams">
      </label>

      <label class="control">Angle
        <input type="range" min="-90" max="90" value="18" aria-label="Angle">
      </label>

      <label class="control">Spread
        <input type="range" min="10" max="140" value="70" aria-label="Spread">
      </label>

      <label class="control">Glow
        <input type="range" min="0" max="100" value="60" aria-label="Glow">
      </label>

      <label class="control">Grain
        <input type="range" min="0" max="100" value="22" aria-label="Grain">
      </label>

      <button class="btn toggle" data-k="theme" aria-pressed="false">Light</button>
      <button class="btn toggle" data-k="pulse" aria-pressed="true">Pulse</button>
      <button class="btn toggle" data-k="grid" aria-pressed="false">Grid</button>
      <button class="btn" data-k="random">Randomize</button>
      <button class="btn" data-k="save">Save PNG</button>
    </div>
  </div>

  <div class="meta">
    <span class="hint">Keys: Space pulse • T theme • G grid • R random • S save</span>
    <span id="last-updated">Last updated: 2026-02-06 17:20:50 EST</span>
  </div>

  <script>
    (function(){
      const root = document.currentScript.closest('.vibe2436');
      const wrap = root.querySelector('.poster-wrap');
      const canvas = root.querySelector('canvas.poster');
      const ctx = canvas.getContext('2d');

      const selPalette = root.querySelector('select[aria-label="Palette"]');
      const inBeams = root.querySelector('input[aria-label="Beams"]');
      const inAngle = root.querySelector('input[aria-label="Angle"]');
      const inSpread = root.querySelector('input[aria-label="Spread"]');
      const inGlow = root.querySelector('input[aria-label="Glow"]');
      const inGrain = root.querySelector('input[aria-label="Grain"]');

      const btnTheme = root.querySelector('.btn.toggle[data-k="theme"]');
      const btnPulse = root.querySelector('.btn.toggle[data-k="pulse"]');
      const btnGrid = root.querySelector('.btn.toggle[data-k="grid"]');
      const btnRandom = root.querySelector('.btn[data-k="random"]');
      const btnSave = root.querySelector('.btn[data-k="save"]');
      const updated = root.querySelector('#last-updated');

      // Timestamp
      try {
        const fmt = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
        updated.textContent = 'Last updated: ' + fmt.format(new Date());
      } catch(_) { updated.textContent = 'Last updated: ' + new Date().toLocaleString(); }

      // Palettes
      const palettes = {
        prism: {
          hue: 210,
          cols: ['#7CF7FF','#6AFFB0','#FFD36B','#FF9FDF','#A6A4FF'],
          bgDark: ['#0b0f18','#0a0d16'],
          bgLight: ['#f5f8ff','#ffffff']
        },
        flora: {
          hue: 132,
          cols: ['#49E58D','#9BFFCD','#E6FF97','#66F3FF','#D9FFD9'],
          bgDark: ['#0b1511','#08110e'],
          bgLight: ['#f4fff7','#ffffff']
        },
        aqua: {
          hue: 196,
          cols: ['#6EE7FF','#77A6FF','#A3E9FF','#7FF7D6','#E0FBFF'],
          bgDark: ['#0a1116','#0a0f13'],
          bgLight: ['#f0fbff','#ffffff']
        },
        ember: {
          hue: 18,
          cols: ['#FF7A59','#FFB36B','#FFD36E','#FFC2A1','#FF9FB0'],
          bgDark: ['#140d0c','#0e0a0a'],
          bgLight: ['#fff6f0','#ffffff']
        },
        void: {
          hue: 220,
          cols: ['#ffffff','#d8e0ff','#a3b6ff','#74ffd1','#ffc7a4'],
          bgDark: ['#0b0e15','#0b0e15'],
          bgLight: ['#eaf0ff','#ffffff']
        }
      };

      function hexToRgba(hex, a=1) {
        if (!hex || typeof hex !== 'string') return hex;
        let h = hex.replace('#','');
        if (h.length === 3) h = h.split('').map(x=>x+x).join('');
        const r = parseInt(h.slice(0,2),16);
        const g = parseInt(h.slice(2,4),16);
        const b = parseInt(h.slice(4,6),16);
        return `rgba(${r},${g},${b},${a})`;
      }

      // State
      let W=1,H=1,dpr=1;
      let beams = +inBeams.value || 18;
      let angleDeg = +inAngle.value || 18;
      let spread = +inSpread.value || 70;
      let glow = (+inGlow.value || 60) / 100;
      let grain = (+inGrain.value || 22) / 100;
      let pulse = true;
      let paletteKey = selPalette.value;
      let hueBase = palettes[paletteKey].hue;
      root.style.setProperty('--h', hueBase);

      let mx = 0.5, my = 0.5;
      let t = 0, running = true;

      // Noise pattern for grain
      let grainPattern = null;
      function makeGrain() {
        const s = 220;
        const gcv = document.createElement('canvas');
        gcv.width = s; gcv.height = s;
        const gtx = gcv.getContext('2d', { alpha: true });
        const id = gtx.createImageData(s, s);
        for (let i=0; i<id.data.length; i+=4) {
          const v = 200 + (Math.random()*55|0); // bright-ish noise
          id.data[i] = id.data[i+1] = id.data[i+2] = v;
          id.data[i+3] = 24 + (Math.random()*64|0);
        }
        gtx.putImageData(id, 0, 0);
        grainPattern = ctx.createPattern(gcv, 'repeat');
      }

      // Resize
      function size() {
        const r = wrap.getBoundingClientRect();
        W = Math.max(1, Math.floor(r.width));
        H = Math.max(1, Math.floor(r.height));
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(W * dpr);
        canvas.height = Math.floor(H * dpr);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }

      // BG fill helper
      function fillBackground() {
        const pal = palettes[paletteKey];
        const isLight = root.classList.contains('light');
        const g1 = ctx.createLinearGradient(0, 0, 0, H);
        const bg = isLight ? pal.bgLight : pal.bgDark;
        g1.addColorStop(0, bg[0]); g1.addColorStop(1, bg[1]);
        ctx.fillStyle = g1; ctx.fillRect(0,0,W,H);

        // pointer halo
        const rad = Math.max(W,H) * (isLight ? 0.7 : 0.85);
        const rg = ctx.createRadialGradient(mx*W, my*H, rad*0.02, mx*W, my*H, rad);
        rg.addColorStop(0, isLight ? 'rgba(255,255,255,0.35)' : 'rgba(255,255,255,0.12)');
        rg.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = rg; ctx.fillRect(0,0,W,H);
      }

      function drawBeams(dt) {
        const cols = palettes[paletteKey].cols;
        // base
        fillBackground();

        // rotate and draw vertical bars
        ctx.save();
        ctx.translate(W/2, H/2);
        const baseAngle = angleDeg * (Math.PI/180);
        const motion = pulse ? Math.sin(t*0.8)*0.12 : 0;
        ctx.rotate(baseAngle + motion);

        const span = Math.hypot(W, H);
        const spacing = Math.max(8, (spread/100) * 64);
        const count = Math.ceil(span / spacing) + 4;

        for (let i=-count; i<=count; i++) {
          const x = i * spacing + (t*60 * (pulse?0.08:0)) % spacing;
          const w = spacing * (0.50 + 0.42*Math.sin(i*0.9 + t*0.6 + glow));
          const col = cols[(i % cols.length + cols.length) % cols.length];
          const grad = ctx.createLinearGradient(x - w/2, -span, x + w/2, span);
          grad.addColorStop(0, hexToRgba(col, root.classList.contains('light') ? 0.65 : 0.85));
          grad.addColorStop(0.5, hexToRgba('#ffffff', glow*0.18));
          grad.addColorStop(1, hexToRgba(col, root.classList.contains('light') ? 0.65 : 0.85));
          ctx.fillStyle = grad;

          ctx.beginPath();
          ctx.rect(x - w/2, -span, w, span*2);
          ctx.fill();

          // soft edge glow
          if (glow > 0.02) {
            const g2 = ctx.createRadialGradient(x, 0, w*0.1, x, 0, w*0.9);
            g2.addColorStop(0, hexToRgba(col, 0.25*glow));
            g2.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g2;
            ctx.beginPath();
            ctx.rect(x - w/2*1.4, -span, w*1.4, span*2);
            ctx.fill();
          }
        }
        ctx.restore();

        // corner vignette
        const vg = ctx.createRadialGradient(0,0,0, 0,0, Math.max(W,H));
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, root.classList.contains('light') ? 'rgba(0,0,0,0.08)' : 'rgba(0,0,0,0.28)');
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = vg; ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'source-over';

        // grain overlay
        if (!grainPattern) makeGrain();
        ctx.save();
        ctx.globalAlpha = Math.min(0.6, grain*0.6);
        ctx.fillStyle = grainPattern;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      function render(dt) {
        // subtle trail for animation smoothness
        const fade = root.classList.contains('light') ? 0.15 : 0.08;
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.globalAlpha = fade * (1.0 - glow*0.4);
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        drawBeams(dt);
      }

      // Pointer interactions
      wrap.addEventListener('pointermove', (e) => {
        const r = wrap.getBoundingClientRect();
        const rx = (e.clientX - r.left)/r.width;
        const ry = (e.clientY - r.top)/r.height;
        mx = rx; my = ry;
        root.style.setProperty('--mx', (e.clientX - root.getBoundingClientRect().left) + 'px');
        root.style.setProperty('--my', (e.clientY - root.getBoundingClientRect().top) + 'px');
        const tiltX = (rx - 0.5) * 10;
        const tiltY = -(ry - 0.5) * 10;
        wrap.style.setProperty('--rx', tiltX + 'deg');
        wrap.style.setProperty('--ry', tiltY + 'deg');
      }, { passive: true });
      wrap.addEventListener('pointerleave', () => {
        wrap.style.setProperty('--rx', '0deg');
        wrap.style.setProperty('--ry', '0deg');
      });

      // Controls
      selPalette.addEventListener('input', () => {
        paletteKey = selPalette.value;
        hueBase = palettes[paletteKey].hue;
        root.style.setProperty('--h', hueBase);
        size();
        render(0.016);
      });
      inBeams.addEventListener('input', () => { beams = +inBeams.value || beams; });
      inAngle.addEventListener('input', () => { angleDeg = +inAngle.value || angleDeg; });
      inSpread.addEventListener('input', () => { spread = +inSpread.value || spread; });
      inGlow.addEventListener('input', () => { glow = (+inGlow.value || 0)/100; });
      inGrain.addEventListener('input', () => { grain = (+inGrain.value || 0)/100; });

      function syncThemeBtn() {
        const isLight = root.classList.contains('light');
        btnTheme.textContent = isLight ? 'Dark' : 'Light';
        btnTheme.setAttribute('aria-pressed', isLight ? 'true' : 'false');
      }
      btnTheme.addEventListener('click', () => {
        root.classList.toggle('light');
        syncThemeBtn();
        size(); render(0.016);
      });

      function syncGridBtn() {
        const showing = wrap.getAttribute('data-grid') === 'true';
        btnGrid.setAttribute('aria-pressed', showing ? 'true' : 'false');
      }
      btnGrid.addEventListener('click', () => {
        const now = wrap.getAttribute('data-grid') !== 'true';
        wrap.setAttribute('data-grid', String(now));
        syncGridBtn();
      });

      btnPulse.addEventListener('click', () => {
        pulse = !pulse;
        btnPulse.setAttribute('aria-pressed', pulse ? 'true' : 'false');
      });

      btnRandom.addEventListener('click', () => {
        // random palette
        const keys = Object.keys(palettes);
        const pk = keys[(Math.random()*keys.length)|0];
        selPalette.value = pk;
        paletteKey = pk;
        hueBase = palettes[paletteKey].hue;
        root.style.setProperty('--h', hueBase);

        // random params
        const bm = (6 + Math.random()*42) | 0;
        beams = bm; inBeams.value = bm;
        angleDeg = Math.floor(-90 + Math.random()*180); inAngle.value = angleDeg;
        spread = Math.floor(20 + Math.random()*120); inSpread.value = spread;
        const gl = Math.floor(30 + Math.random()*70); glow = gl/100; inGlow.value = gl;
        const gr = Math.floor(Math.random()*40); grain = gr/100; inGrain.value = gr;

        render(0.016);
      });

      btnSave.addEventListener('click', () => {
        try {
          const tmp = document.createElement('canvas');
          const d = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          tmp.width = Math.floor(W * d);
          tmp.height = Math.floor(H * d);
          const c2 = tmp.getContext('2d');
          c2.setTransform(d,0,0,d,0,0);

          // replicate to offscreen
          // local copies of state
          const saveCtx = c2;
          const oldCtx = ctx;
          const bakCanvas = canvas;

          // utilities reuse
          (function drawOffscreen(){
            // background
            const pal = palettes[paletteKey];
            const isLight = root.classList.contains('light');
            const g1 = saveCtx.createLinearGradient(0, 0, 0, H);
            const bg = isLight ? pal.bgLight : pal.bgDark;
            g1.addColorStop(0, bg[0]); g1.addColorStop(1, bg[1]);
            saveCtx.fillStyle = g1; saveCtx.fillRect(0,0,W,H);
            const rad = Math.max(W,H) * (isLight ? 0.7 : 0.85);
            const rg = saveCtx.createRadialGradient(mx*W, my*H, rad*0.02, mx*W, my*H, rad);
            rg.addColorStop(0, isLight ? 'rgba(255,255,255,0.35)' : 'rgba(255,255,255,0.12)');
            rg.addColorStop(1, 'rgba(255,255,255,0)');
            saveCtx.fillStyle = rg; saveCtx.fillRect(0,0,W,H);

            // beams
            const cols = pal.cols;
            saveCtx.save();
            saveCtx.translate(W/2, H/2);
            const baseAngle = angleDeg * (Math.PI/180);
            saveCtx.rotate(baseAngle);
            const span = Math.hypot(W, H);
            const spacing = Math.max(8, (spread/100) * 64);
            const count = Math.ceil(span / spacing) + 4;
            for (let i=-count; i<=count; i++) {
              const x = i * spacing;
              const w = spacing * (0.50 + 0.42*Math.sin(i*0.9 + glow));
              const col = cols[(i % cols.length + cols.length) % cols.length];
              const grad = saveCtx.createLinearGradient(x - w/2, -span, x + w/2, span);
              grad.addColorStop(0, hexToRgba(col, isLight ? 0.65 : 0.85));
              grad.addColorStop(0.5, hexToRgba('#ffffff', glow*0.18));
              grad.addColorStop(1, hexToRgba(col, isLight ? 0.65 : 0.85));
              saveCtx.fillStyle = grad;
              saveCtx.beginPath(); saveCtx.rect(x - w/2, -span, w, span*2); saveCtx.fill();

              if (glow > 0.02) {
                const g2 = saveCtx.createRadialGradient(x, 0, w*0.1, x, 0, w*0.9);
                g2.addColorStop(0, hexToRgba(col, 0.25*glow));
                g2.addColorStop(1, 'rgba(255,255,255,0)');
                saveCtx.fillStyle = g2;
                saveCtx.beginPath(); saveCtx.rect(x - w/2*1.4, -span, w*1.4, span*2); saveCtx.fill();
              }
            }
            saveCtx.restore();

            const vg = saveCtx.createRadialGradient(0,0,0, 0,0, Math.max(W,H));
            vg.addColorStop(0, 'rgba(0,0,0,0)');
            vg.addColorStop(1, isLight ? 'rgba(0,0,0,0.08)' : 'rgba(0,0,0,0.28)');
            saveCtx.globalCompositeOperation = 'multiply';
            saveCtx.fillStyle = vg; saveCtx.fillRect(0,0,W,H);
            saveCtx.globalCompositeOperation = 'source-over';

            if (!grainPattern) makeGrain();
            saveCtx.save();
            saveCtx.globalAlpha = Math.min(0.6, grain*0.6);
            saveCtx.fillStyle = grainPattern;
            saveCtx.fillRect(0,0,W,H);
            saveCtx.restore();
          })();

          const a = document.createElement('a');
          a.download = 'prism-atelier-' + Date.now() + '.png';
          a.href = tmp.toDataURL('image/png');
          a.click();
        } catch(_) {}
      });

      // Keyboard
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === ' ') { e.preventDefault(); btnPulse.click(); }
        if (k === 't') { e.preventDefault(); btnTheme.click(); }
        if (k === 'g') { e.preventDefault(); btnGrid.click(); }
        if (k === 'r') { e.preventDefault(); btnRandom.click(); }
        if (k === 's') { e.preventDefault(); btnSave.click(); }
      });

      // Loop
      function loop(now) {
        if (!running) return;
        const dt = Math.min(0.033, Math.max(0.005, (loop._last ? (now - loop._last) : 16) / 1000));
        loop._last = now;
        t += dt;
        render(dt);
        requestAnimationFrame(loop);
      }

      // Init
      size();
      makeGrain();
      const ro = new ResizeObserver(size);
      ro.observe(wrap);

      // Respect reduced motion
      const mql = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
      if (mql && mql.matches) { running = false; btnPulse.setAttribute('aria-pressed','false'); pulse = false; render(0.016); }
      else { running = true; requestAnimationFrame(loop); }
      if (mql && mql.addEventListener) {
        mql.addEventListener('change', (e) => {
          running = !e.matches;
          pulse = !e.matches;
          btnPulse.setAttribute('aria-pressed', pulse ? 'true' : 'false');
          if (running) { loop._last = performance.now(); requestAnimationFrame(loop); }
        });
      }

      // Sync controls UI
      syncThemeBtn(); syncGridBtn();
    })();
  </script>
</section>
      </section>
      <!-- END_EDITABLE -->
    <script>
      // Only show a local placeholder if the agent hasn't written a timestamp yet
      const el = document.getElementById('last-updated');
      if (el && (!el.textContent || el.textContent.includes('not yet'))) {
        const now = new Date();
        el.textContent = `Last updated: ${now.toLocaleString(undefined, { hour12: false })}`;
      }
    </script>
  </body>
  </html>


