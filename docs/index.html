<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibing</title>
    <style>
      :root {
        --bg: #0f1221;
        --fg: #e6e8f0;
        --muted: #9aa3b2;
        --accent: #8b5cf6;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--fg);
        background: radial-gradient(1200px 800px at 70% 10%, #1b1f3a, var(--bg));
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 28px 24px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        backdrop-filter: blur(6px);
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 28px;
        letter-spacing: 0.3px;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 18px;
      }
      #content {
        font-size: 18px;
        line-height: 1.6;
        background: rgba(255,255,255,0.04);
        border: 1px dashed rgba(255,255,255,0.12);
        border-radius: 12px;
        padding: 16px;
      }
      .footer {
        margin-top: 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: var(--muted);
      }
      .badge {
        display: inline-block;
        background: rgba(139, 92, 246, 0.18);
        color: #d4c2ff;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(139, 92, 246, 0.35);
        letter-spacing: 0.2px;
      }
    </style>
  </head>
  <body>
    <!-- BEGIN_EDITABLE -->
      <section id="content">
<section class="vibe2437 orbit-garden" role="region" aria-label="Orbit Garden — kinetic microverse">
  <style>
    .vibe2437 {
      --r: 28px;
      --ink: 220 22% 95%;
      --muted: 220 12% 72%;
      --line: 220 16% 26%;
      --bg1: hsl(230 35% 8%);
      --bg2: hsl(230 28% 5%);
      --h: 210;
      --mx: 50%;
      --my: 50%;
      position: relative;
      overflow: hidden;
      color: hsl(var(--ink));
      padding: clamp(18px, 5.8vw, 64px);
      border: 1px solid hsl(var(--line));
      border-radius: var(--r);
      font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", Segoe UI, Roboto, "Helvetica Neue", Arial;
      background:
        radial-gradient(1000px 720px at var(--mx) var(--my), hsl(var(--h) 98% 60% / 0.16), transparent 60%),
        radial-gradient(140% 120% at 30% 10%, hsl(270 60% 22% / 0.3), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      box-shadow: 0 50px 140px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.06);
      isolation: isolate;
    }
    .vibe2437::before, .vibe2437::after {
      content: "";
      position: absolute; inset: -35%;
      filter: blur(90px) saturate(140%);
      pointer-events: none;
      background:
        conic-gradient(from 0deg at 60% 40%,
          hsl(calc(var(--h) + 0) 95% 60% / 0.00) 0deg,
          hsl(calc(var(--h) + 40) 95% 60% / 0.10) 90deg,
          hsl(calc(var(--h) + 160) 95% 60% / 0.10) 180deg,
          hsl(calc(var(--h) + 220) 95% 60% / 0.12) 270deg,
          transparent 360deg);
      mix-blend-mode: screen;
      animation: v2437_swirl 36s linear infinite;
      z-index: 0;
    }
    .vibe2437::after { animation-direction: reverse; opacity: 0.8; }
    @keyframes v2437_swirl { to { transform: rotate(360deg) scale(1.02); } }

    .vibe2437.light {
      --ink: 232 18% 12%;
      --muted: 232 12% 42%;
      --line: 232 22% 86%;
      --bg1: #f7f9ff;
      --bg2: #ffffff;
      box-shadow: 0 40px 120px rgba(25,35,75,0.16), inset 0 1px 0 #fff;
    }
    .vibe2437.light::before, .vibe2437.light::after { mix-blend-mode: multiply; }

    .vibe2437 * { box-sizing: border-box; }

    /* Header */
    .vibe2437 .head {
      position: relative; z-index: 2;
      display: grid; gap: 10px; justify-items: center; text-align: center;
      margin-bottom: clamp(20px, 4.8vw, 36px);
    }
    .vibe2437 .eyebrow {
      display: inline-flex; align-items: center; gap: 10px; padding: 8px 12px;
      font-size: 11px; letter-spacing: 0.14em; text-transform: uppercase; color: hsl(var(--muted));
      border-radius: 999px; border: 1px solid hsl(var(--line));
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      backdrop-filter: blur(6px);
    }
    .vibe2437.light .eyebrow {
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.72));
    }
    .vibe2437 .gem {
      width: 10px; height: 10px; border-radius: 4px;
      background: linear-gradient(135deg, hsl(var(--h) 92% 60%), hsl(calc(var(--h)+90) 92% 62%));
      box-shadow: 0 0 12px hsl(var(--h) 92% 58% / 0.6);
      animation: v2437_pulse 3s ease-in-out infinite;
    }
    @keyframes v2437_pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.25);} }

    .vibe2437 .title {
      margin: 0; line-height: 0.88;
      font-size: clamp(44px, 9vw, 112px);
      letter-spacing: -0.02em;
      background: linear-gradient(90deg,
        hsl(calc(var(--h)-30) 92% 65%),
        hsl(calc(var(--h)+10) 92% 60%),
        hsl(calc(var(--h)+120) 88% 62%));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      filter: drop-shadow(0 10px 24px rgba(0,0,0,0.12));
      text-wrap: balance; white-space: nowrap;
    }
    .vibe2437 .lede {
      margin: 2px 0 0; color: hsl(var(--muted));
      font-size: clamp(14px, 2vw, 18px);
      max-width: 70ch; text-wrap: pretty;
    }

    /* Stage / Orb */
    .vibe2437 .stage { position: relative; z-index: 2; display: grid; gap: 18px; justify-items: center; }

    .vibe2437 .orb-wrap {
      --rx: 0deg; --ry: 0deg;
      position: relative;
      width: min(86vw, 820px);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      border: 1px solid hsl(var(--line));
      overflow: hidden;
      transform: perspective(1200px) rotateX(var(--ry)) rotateY(var(--rx));
      transition: transform .15s ease-out, box-shadow .25s ease;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.08),
        inset 0 -60px 120px rgba(0,0,0,0.35),
        0 30px 110px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      background:
        radial-gradient(120% 120% at 60% 30%, rgba(255,255,255,0.12), rgba(255,255,255,0.02) 60%),
        radial-gradient(circle at 30% 70%, rgba(255,255,255,0.06), transparent 55%);
      animation: v2437_breathe 6s ease-in-out infinite;
    }
    @keyframes v2437_breathe { 0%,100% { transform: perspective(1200px) rotateX(var(--ry)) rotateY(var(--rx)) scale(1); } 50% { transform: perspective(1200px) rotateX(calc(var(--ry) * 1.0)) rotateY(calc(var(--rx) * 1.0)) scale(1.01); } }

    .vibe2437.light .orb-wrap {
      box-shadow:
        inset 0 1px 0 #fff,
        inset 0 -50px 110px rgba(25,35,75,0.12),
        0 26px 90px rgba(25,35,75,0.16);
      background:
        radial-gradient(120% 120% at 60% 30%, rgba(255,255,255,0.65), rgba(255,255,255,0.18) 60%),
        radial-gradient(circle at 30% 70%, rgba(0,0,0,0.05), transparent 55%);
    }

    .vibe2437 canvas.universe {
      position: absolute; inset: 0; width: 100%; height: 100%; display: block;
    }

    .vibe2437 .rim {
      position: absolute; inset: 0; pointer-events: none; border-radius: 50%;
      box-shadow:
        inset 0 0 0 1px hsl(var(--line)),
        inset 0 0 80px rgba(255,255,255,0.12),
        inset 0 80px 160px rgba(0,0,0,0.35);
      mix-blend-mode: soft-light;
    }
    .vibe2437.light .rim {
      box-shadow:
        inset 0 0 0 1px hsl(var(--line)),
        inset 0 0 80px rgba(255,255,255,0.75),
        inset 0 80px 160px rgba(0,0,0,0.08);
      mix-blend-mode: multiply;
    }

    /* Controls */
    .vibe2437 .dock {
      display: grid; gap: 12px; grid-template-columns: repeat(6, minmax(0, 1fr));
      width: min(90vw, 900px);
    }
    @media (max-width: 880px) { .vibe2437 .dock { grid-template-columns: 1fr 1fr; } }

    .vibe2437 .control, .vibe2437 .select, .vibe2437 .btn {
      display: flex; align-items: center; justify-content: space-between; gap: 10px;
      padding: 12px 14px;
      border: 1px solid hsl(var(--line)); border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      color: hsl(var(--ink)); backdrop-filter: blur(6px);
      box-shadow: 0 14px 36px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.06);
    }
    .vibe2437.light .control, .vibe2437.light .select, .vibe2437.light .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(255,255,255,0.72));
      box-shadow: 0 12px 34px rgba(25,35,75,0.12), inset 0 1px 0 #fff;
    }

    .vibe2437 select {
      appearance: none; border: none; background: transparent; color: inherit; font: inherit; padding-right: 18px; cursor: pointer;
    }
    .vibe2437 .select::after {
      content: "▾"; margin-left: auto; opacity: .6;
    }

    .vibe2437 input[type="range"] {
      appearance: none; inline-size: 56%; min-inline-size: 140px; block-size: 8px;
      background: rgba(255,255,255,0.12); border-radius: 999px; border: 1px solid hsl(var(--line));
    }
    .vibe2437.light input[type="range"] { background: rgba(0,0,0,0.08); }
    .vibe2437 input[type="range"]::-webkit-slider-thumb {
      appearance: none; width: 18px; height: 18px; border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff, hsl(var(--h) 92% 60%) 60%);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 6px 16px hsl(var(--h) 90% 55% / 0.35);
      cursor: pointer;
    }
    .vibe2437 input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border: none; border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #fff, hsl(var(--h) 92% 60%) 60%);
      box-shadow: 0 6px 16px hsl(var(--h) 90% 55% / 0.35); cursor: pointer;
    }

    .vibe2437 .btn {
      appearance: none; cursor: pointer; font-weight: 700; letter-spacing: 0.2px;
      transition: transform .15s ease, box-shadow .25s ease, background .25s ease;
      justify-content: center; user-select: none;
    }
    .vibe2437 .btn:hover { transform: translateY(-1px); }
    .vibe2437 .btn[aria-pressed="true"] {
      color: #0b0f18;
      background: linear-gradient(180deg, hsl(var(--h) 92% 64%), hsl(var(--h) 92% 56%));
      border-color: transparent;
      box-shadow: 0 14px 34px hsl(var(--h) 90% 55% / 0.42);
    }

    /* Meta */
    .vibe2437 .meta {
      margin-top: 14px; color: hsl(var(--muted)); font-size: 12px;
      display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;
      position: relative; z-index: 2;
    }
    .vibe2437 .meta a { color: inherit; text-decoration: underline dotted; text-underline-offset: 3px; }

    /* Focus */
    .vibe2437 .control:focus-within,
    .vibe2437 .select:focus-within,
    .vibe2437 .btn:focus-visible,
    .vibe2437 input[type="range"]:focus-visible,
    .vibe2437 select:focus-visible {
      outline: none; box-shadow: 0 0 0 3px hsl(var(--h) 90% 60% / 0.35);
    }
  </style>

  <div class="head" role="group" aria-label="Header">
    <span class="eyebrow"><i class="gem" aria-hidden="true"></i> Edition 2437 — Orbit Garden</span>
    <h1 class="title" aria-label="Orbit Garden">Kinetic Microverse</h1>
    <p class="lede">A living sphere of orbits, threads, and sparks. Tilt to peer inside, then tune the universe.</p>
  </div>

  <div class="stage">
    <div class="orb-wrap" role="img" aria-label="Generative orb">
      <canvas class="universe"></canvas>
      <div class="rim" aria-hidden="true"></div>
    </div>

    <div class="dock" role="group" aria-label="Controls">
      <label class="select">Mode
        <select aria-label="Mode">
          <option value="aurora" selected>Aurora</option>
          <option value="dawn">Dawn</option>
          <option value="nocturne">Nocturne</option>
          <option value="citrus">Citrus</option>
          <option value="mono">Mono</option>
        </select>
      </label>

      <label class="control">Orbits
        <input type="range" min="3" max="26" value="12" aria-label="Orbits">
      </label>

      <label class="control">Weave
        <input type="range" min="0" max="100" value="28" aria-label="Weave">
      </label>

      <label class="control">Drift
        <input type="range" min="0" max="100" value="40" aria-label="Drift">
      </label>

      <button class="btn toggle" data-k="bloom" aria-pressed="true">Bloom</button>
      <button class="btn toggle" data-k="animate" aria-pressed="true">Animate</button>
      <button class="btn toggle" data-k="theme" aria-pressed="false">Light</button>
      <button class="btn" data-k="random">Randomize</button>
      <button class="btn" data-k="save">Save PNG</button>
    </div>
  </div>

  <div class="meta">
    <span class="hint">Keys: A animate • B bloom • T theme • R random • S save</span>
    <span id="last-updated">Last updated: 2026-02-06 18:23:55 EST</span>
  </div>

  <script>
    (function(){
      const root = document.currentScript.closest('.vibe2437');
      const orb = root.querySelector('.orb-wrap');
      const canvas = root.querySelector('canvas.universe');
      const ctx = canvas.getContext('2d');

      // Controls
      const selMode = root.querySelector('select[aria-label="Mode"]');
      const inOrbits = root.querySelector('input[aria-label="Orbits"]');
      const inWeave = root.querySelector('input[aria-label="Weave"]');
      const inDrift = root.querySelector('input[aria-label="Drift"]');
      const btnBloom = root.querySelector('.btn.toggle[data-k="bloom"]');
      const btnAnim = root.querySelector('.btn.toggle[data-k="animate"]');
      const btnTheme = root.querySelector('.btn.toggle[data-k="theme"]');
      const btnRandom = root.querySelector('.btn[data-k="random"]');
      const btnSave = root.querySelector('.btn[data-k="save"]');
      const updated = root.querySelector('#last-updated');

      // Timestamp
      try {
        const fmt = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
        updated.textContent = 'Last updated: ' + fmt.format(new Date());
      } catch(_) { updated.textContent = 'Last updated: ' + new Date().toLocaleString(); }

      // Palettes
      const palettes = {
        aurora: {
          hue: 200,
          cols: ['#7CF7FF','#6AFFB0','#A6A4FF','#FF9FDF','#FFD36B'],
          bgDark: ['#0b0f18','#0a0d16'],
          bgLight: ['#f5f8ff','#ffffff']
        },
        dawn: {
          hue: 18,
          cols: ['#FFB36B','#FFD36E','#FFC2A1','#FF9FB0','#E9D7FF'],
          bgDark: ['#191214','#130e10'],
          bgLight: ['#fff7f1','#ffffff']
        },
        nocturne: {
          hue: 265,
          cols: ['#B79BFF','#7AA8FF','#5CF1FF','#9BFFCD','#E4E8FF'],
          bgDark: ['#0b0e15','#0a0c14'],
          bgLight: ['#eef2ff','#ffffff']
        },
        citrus: {
          hue: 90,
          cols: ['#E5FF5C','#7BFF9C','#7FF7D6','#FFE08C','#FFA96B'],
          bgDark: ['#0f130b','#0d120b'],
          bgLight: ['#f7ffea','#ffffff']
        },
        mono: {
          hue: 220,
          cols: ['#ffffff','#e6e9ef','#bfc6d9','#8ea0c7','#5a79b0'],
          bgDark: ['#0b0e12','#0b0e12'],
          bgLight: ['#eef2f7','#ffffff']
        }
      };

      function hexToRgb(hex) {
        let h = hex.replace('#','').trim();
        if (h.length === 3) h = h.split('').map(x=>x+x).join('');
        const r = parseInt(h.slice(0,2),16);
        const g = parseInt(h.slice(2,4),16);
        const b = parseInt(h.slice(4,6),16);
        return [r,g,b];
      }
      function rgbaStr([r,g,b], a=1){ return `rgba(${r},${g},${b},${a})`; }
      function mix(a, b, t){ return a + (b - a) * t; }
      function mixRgb(c1, c2, t) {
        return [mix(c1[0], c2[0], t), mix(c1[1], c2[1], t), mix(c1[2], c2[2], t)];
      }

      // State
      let W=1,H=1,dpr=1, CX=0, CY=0, RAD=0;
      let mode = selMode.value;
      let orbits = +inOrbits.value || 12;
      let weave = (+inWeave.value || 28) / 100; // 0..1
      let drift = (+inDrift.value || 40) / 100; // 0..1
      let bloom = true;
      let animate = true;

      let mx = 0.5, my = 0.5;
      let t = 0, running = true;

      // Rings data
      let rings = [];
      function rebuild() {
        rings = [];
        const cols = palettes[mode].cols.map(hexToRgb);
        for (let i=0; i<orbits; i++) {
          const f = i/(orbits-1 || 1);
          const r = mix(RAD*0.16, RAD*0.88, f) + (Math.random()-0.5)*RAD*0.01;
          const speed = mix(0.15, 1.2, 1 - f) * (0.4 + drift*1.2);
          const count = 8 + ((i*3 + 7) % 24);
          const phase = Math.random()*Math.PI*2;
          // color across palette
          const pos = f * (cols.length-1);
          const lo = Math.floor(pos), hi = Math.min(cols.length-1, lo+1);
          const ct = pos - lo;
          const col = mixRgb(cols[lo], cols[hi], ct);
          rings.push({ r, speed, count, phase, col });
        }
      }

      // Grain pattern
      let grainPattern = null;
      function makeGrain() {
        const s = 200;
        const gcv = document.createElement('canvas');
        gcv.width = s; gcv.height = s;
        const gtx = gcv.getContext('2d');
        const id = gtx.createImageData(s, s);
        for (let i=0; i<id.data.length; i+=4) {
          const v = 200 + (Math.random()*55|0);
          id.data[i] = id.data[i+1] = id.data[i+2] = v;
          id.data[i+3] = 18 + (Math.random()*60|0);
        }
        gtx.putImageData(id, 0, 0);
        grainPattern = ctx.createPattern(gcv, 'repeat');
      }

      // Resize
      function size() {
        const r = orb.getBoundingClientRect();
        W = Math.max(1, Math.floor(r.width));
        H = Math.max(1, Math.floor(r.height));
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(W * dpr);
        canvas.height = Math.floor(H * dpr);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(dpr,0,0,dpr,0,0);
        CX = W/2; CY = H/2; RAD = Math.min(W, H)/2 - 8;
        rebuild();
      }

      // Background fill inside orb
      function fillOrb() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(CX, CY, RAD, 0, Math.PI*2);
        ctx.clip();

        const pal = palettes[mode];
        const isLight = root.classList.contains('light');
        const g1 = ctx.createRadialGradient(CX, CY, RAD*0.05, CX, CY, RAD);
        g1.addColorStop(0, isLight ? 'rgba(255,255,255,0.75)' : 'rgba(255,255,255,0.10)');
        g1.addColorStop(1, isLight ? 'rgba(255,255,255,0.0)' : 'rgba(0,0,0,0.18)');
        ctx.fillStyle = g1; ctx.fillRect(CX-RAD, CY-RAD, RAD*2, RAD*2);

        // soft pointer halo
        const px = mix(CX - RAD*0.5, CX + RAD*0.5, mx);
        const py = mix(CY - RAD*0.5, CY + RAD*0.5, my);
        const rg = ctx.createRadialGradient(px, py, RAD*0.02, px, py, RAD*0.9);
        rg.addColorStop(0, isLight ? 'rgba(255,255,255,0.40)' : 'rgba(255,255,255,0.18)');
        rg.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = rg; ctx.fillRect(CX-RAD, CY-RAD, RAD*2, RAD*2);

        ctx.restore();
      }

      function drawUniverse(dt) {
        // Fade trails
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        const fade = root.classList.contains('light') ? 0.18 : 0.08;
        ctx.globalAlpha = fade * (bloom ? 0.8 : 0.6);
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        // Orb background
        fillOrb();

        // Orbits + nodes
        ctx.save();
        // mild perspective via y-scale responding to pointer
        const tilt = (my - 0.5) * 0.18;
        ctx.translate(CX, CY);
        ctx.scale(1, 1 - tilt);

        for (let i=0; i<rings.length; i++) {
          const ring = rings[i];
          ring.phase += ring.speed * dt * (animate ? 1 : 0);
          const r = ring.r;
          const col = ring.col;
          const baseAlpha = 0.15 + 0.35 * (i / (rings.length-1 || 1));
          const glowA = bloom ? 0.45 : 0.18;

          // orbit path
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI*2);
          ctx.strokeStyle = rgbaStr(col, baseAlpha);
          ctx.lineWidth = 1;
          ctx.stroke();

          // nodes
          const count = ring.count;
          for (let j=0; j<count; j++) {
            const ang = ring.phase + j * (Math.PI*2 / count);
            const x = Math.cos(ang) * r;
            const y = Math.sin(ang) * r;

            // node glow
            const g = ctx.createRadialGradient(x, y, 0, x, y, 10);
            g.addColorStop(0, rgbaStr(col, glowA));
            g.addColorStop(1, rgbaStr(col, 0));
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI*2); ctx.fill();

            // core
            ctx.fillStyle = rgbaStr([255,255,255], 0.8);
            ctx.beginPath(); ctx.arc(x, y, 1.6, 0, Math.PI*2); ctx.fill();

            // weave to neighbor ring
            if (weave > 0 && i < rings.length - 1 && j % Math.max(2, (3 - (i%3))) === 0) {
              if (Math.random() < weave * 0.3) {
                const nxt = rings[i+1];
                const ang2 = nxt.phase + (j % nxt.count) * (Math.PI*2 / nxt.count);
                const x2 = Math.cos(ang2) * nxt.r;
                const y2 = Math.sin(ang2) * nxt.r;
                ctx.strokeStyle = rgbaStr(col, 0.25 * weave);
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                // subtle arc
                ctx.moveTo(x, y);
                const cx1 = x * 0.6, cy1 = y * 0.6;
                const cx2 = x2 * 0.6, cy2 = y2 * 0.6;
                ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
                ctx.stroke();
              }
            }
          }
        }
        ctx.restore();

        // edge vignette
        ctx.save();
        ctx.beginPath();
        ctx.arc(CX, CY, RAD, 0, Math.PI*2);
        ctx.clip();
        const vg = ctx.createRadialGradient(CX, CY, RAD*0.6, CX, CY, RAD);
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, root.classList.contains('light') ? 'rgba(0,0,0,0.08)' : 'rgba(0,0,0,0.28)');
        ctx.fillStyle = vg; ctx.fillRect(CX-RAD, CY-RAD, RAD*2, RAD*2);
        ctx.restore();

        // grain
        if (!grainPattern) makeGrain();
        ctx.save();
        ctx.globalAlpha = root.classList.contains('light') ? 0.12 : 0.18;
        ctx.fillStyle = grainPattern;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      function render(dt) { drawUniverse(dt); }

      // Pointer interactions (parallax + gradient anchor)
      orb.addEventListener('pointermove', (e) => {
        const r = orb.getBoundingClientRect();
        const rx = (e.clientX - r.left)/r.width;
        const ry = (e.clientY - r.top)/r.height;
        mx = rx; my = ry;
        root.style.setProperty('--mx', (e.clientX - root.getBoundingClientRect().left) + 'px');
        root.style.setProperty('--my', (e.clientY - root.getBoundingClientRect().top) + 'px');
        const tiltX = (rx - 0.5) * 10;
        const tiltY = -(ry - 0.5) * 10;
        orb.style.setProperty('--rx', tiltX + 'deg');
        orb.style.setProperty('--ry', tiltY + 'deg');
      }, { passive: true });
      orb.addEventListener('pointerleave', () => {
        orb.style.setProperty('--rx', '0deg');
        orb.style.setProperty('--ry', '0deg');
      });

      // Control bindings
      selMode.addEventListener('input', () => {
        mode = selMode.value;
        root.style.setProperty('--h', palettes[mode].hue);
        rebuild();
        render(0.016);
      });
      inOrbits.addEventListener('input', () => { orbits = +inOrbits.value || orbits; rebuild(); });
      inWeave.addEventListener('input', () => { weave = (+inWeave.value || 0)/100; });
      inDrift.addEventListener('input', () => { drift = (+inDrift.value || 0)/100; rebuild(); });

      function syncBloomBtn(){ btnBloom.setAttribute('aria-pressed', bloom ? 'true' : 'false'); }
      btnBloom.addEventListener('click', () => { bloom = !bloom; syncBloomBtn(); });

      function syncAnimBtn(){ btnAnim.setAttribute('aria-pressed', animate ? 'true' : 'false'); }
      btnAnim.addEventListener('click', () => { animate = !animate; syncAnimBtn(); });

      function syncThemeBtn() {
        const isLight = root.classList.contains('light');
        btnTheme.textContent = isLight ? 'Dark' : 'Light';
        btnTheme.setAttribute('aria-pressed', isLight ? 'true' : 'false');
      }
      btnTheme.addEventListener('click', () => {
        root.classList.toggle('light');
        syncThemeBtn(); render(0.016);
      });

      btnRandom.addEventListener('click', () => {
        const keys = Object.keys(palettes);
        const pk = keys[(Math.random()*keys.length)|0];
        selMode.value = pk; mode = pk; root.style.setProperty('--h', palettes[mode].hue);

        const ob = (3 + Math.random()*23) | 0; orbits = ob; inOrbits.value = ob;
        const wv = (Math.random()*100) | 0; weave = wv/100; inWeave.value = wv;
        const dr = (10 + Math.random()*90) | 0; drift = dr/100; inDrift.value = dr;

        bloom = Math.random() > 0.25; syncBloomBtn();
        rebuild(); render(0.016);
      });

      btnSave.addEventListener('click', () => {
        try {
          const a = document.createElement('a');
          a.download = 'orbit-garden-' + Date.now() + '.png';
          a.href = canvas.toDataURL('image/png');
          a.click();
        } catch(_) {}
      });

      // Keyboard
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'a') { e.preventDefault(); btnAnim.click(); }
        if (k === 'b') { e.preventDefault(); btnBloom.click(); }
        if (k === 't') { e.preventDefault(); btnTheme.click(); }
        if (k === 'r') { e.preventDefault(); btnRandom.click(); }
        if (k === 's') { e.preventDefault(); btnSave.click(); }
      });

      // Loop
      function loop(now) {
        if (!running) return;
        const dt = Math.min(0.033, Math.max(0.005, (loop._last ? (now - loop._last) : 16) / 1000));
        loop._last = now;
        t += dt;
        render(dt);
        requestAnimationFrame(loop);
      }

      // Init
      root.style.setProperty('--h', palettes[mode].hue);
      size(); makeGrain(); rebuild();

      const ro = new ResizeObserver(size);
      ro.observe(orb);

      // Respect reduced motion
      const mql = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
      if (mql && mql.matches) { running = false; animate = false; syncAnimBtn(); render(0.016); }
      else { running = true; requestAnimationFrame(loop); }
      if (mql && mql.addEventListener) {
        mql.addEventListener('change', (e) => {
          running = !e.matches;
          animate = !e.matches;
          syncAnimBtn();
          if (running) { loop._last = performance.now(); requestAnimationFrame(loop); }
        });
      }

      // Sync toggles
      syncBloomBtn(); syncAnimBtn(); syncThemeBtn();
    })();
  </script>
</section>
      </section>
      <!-- END_EDITABLE -->
    <script>
      // Only show a local placeholder if the agent hasn't written a timestamp yet
      const el = document.getElementById('last-updated');
      if (el && (!el.textContent || el.textContent.includes('not yet'))) {
        const now = new Date();
        el.textContent = `Last updated: ${now.toLocaleString(undefined, { hour12: false })}`;
      }
    </script>
  </body>
  </html>


