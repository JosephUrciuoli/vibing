<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibing</title>
    <style>
      :root {
        --bg: #0f1221;
        --fg: #e6e8f0;
        --muted: #9aa3b2;
        --accent: #8b5cf6;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--fg);
        background: radial-gradient(1200px 800px at 70% 10%, #1b1f3a, var(--bg));
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 28px 24px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        backdrop-filter: blur(6px);
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 28px;
        letter-spacing: 0.3px;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 18px;
      }
      #content {
        font-size: 18px;
        line-height: 1.6;
        background: rgba(255,255,255,0.04);
        border: 1px dashed rgba(255,255,255,0.12);
        border-radius: 12px;
        padding: 16px;
      }
      .footer {
        margin-top: 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: var(--muted);
      }
      .badge {
        display: inline-block;
        background: rgba(139, 92, 246, 0.18);
        color: #d4c2ff;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(139, 92, 246, 0.35);
        letter-spacing: 0.2px;
      }
    </style>
  </head>
  <body>
    <!-- BEGIN_EDITABLE -->
      <section id="content">
<div class="vibe-1865" data-scheme="nocturne" aria-label="The Orrery Chamber — a living study of motion">
  <style>
    .vibe-1865 {
      --r: 28px;
      --fg: #eaf1ff;
      --muted: #a9b3cf;
      --bg1: #050712;
      --bg2: #0b1130;
      --edge: rgba(255,255,255,0.10);
      --acc1: #81d4ff;
      --acc2: #a57aff;
      --glow: rgba(160,180,255,0.35);
      --fade-rgb: 6, 9, 22;
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Inter, Segoe UI, Roboto, Helvetica, Arial;
      letter-spacing: 0.1px;
      position: relative;
      isolation: isolate;
    }
    .vibe-1865[data-scheme="aurora"]{
      --fg: #0b1020;
      --muted: #54607b;
      --bg1: #fff7ea;
      --bg2: #e9fff2;
      --edge: rgba(10,18,40,0.14);
      --acc1: #ff8a7a;
      --acc2: #ffb76b;
      --glow: rgba(255,160,120,0.25);
      --fade-rgb: 252, 248, 236;
    }
    .vibe-1865[data-scheme="mono"]{
      --fg: #eef2f7;
      --muted: #bcc6d1;
      --bg1: #0c0e13;
      --bg2: #1a1f27;
      --edge: rgba(255,255,255,0.12);
      --acc1: #98a7b7;
      --acc2: #d7dee6;
      --glow: rgba(200,210,220,0.28);
      --fade-rgb: 10, 12, 16;
    }

    .vibe-1865 .poster {
      position: relative;
      border-radius: var(--r);
      overflow: hidden;
      min-height: clamp(560px, 72vmin, 860px);
      background: radial-gradient(120% 120% at -10% 120%, color-mix(in oklab, var(--acc2) 14%, transparent) 0 40%, transparent 70%),
                  radial-gradient(120% 120% at 110% -10%, color-mix(in oklab, var(--acc1) 12%, transparent) 0 40%, transparent 70%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
      border: 1px solid color-mix(in oklab, var(--edge), transparent 35%);
      box-shadow: 0 30px 80px rgba(0,0,0,0.45), 0 1px 0 rgba(255,255,255,0.05) inset;
    }

    /* Atmospheric layers */
    .vibe-1865 .nebula,
    .vibe-1865 .grid,
    .vibe-1865 .halo {
      position: absolute; inset: 0; pointer-events: none;
    }
    .vibe-1865 .nebula {
      background:
        radial-gradient(800px 600px at 25% 70%, color-mix(in oklab, var(--acc2) 10%, transparent), transparent 70%),
        radial-gradient(900px 700px at 80% 20%, color-mix(in oklab, var(--acc1) 10%, transparent), transparent 70%);
      filter: blur(10px) saturate(1.05);
      opacity: 0.55;
      mix-blend-mode: overlay;
      animation: nebula-drift 60s linear infinite;
    }
    @keyframes nebula-drift {
      0% { transform: translate3d(0,0,0) rotate(0deg) scale(1); }
      50%{ transform: translate3d(2%, -2%, 0) rotate(12deg) scale(1.03); }
      100%{ transform: translate3d(0,0,0) rotate(0deg) scale(1); }
    }

    .vibe-1865 .grid {
      background:
        repeating-radial-gradient(circle at 50% 50%,
          rgba(255,255,255,0.08) 0 1px,
          transparent 1px 46px),
        repeating-conic-gradient(from 0deg,
          rgba(255,255,255,0.05) 0 3deg,
          transparent 3deg 15deg);
      mask: radial-gradient(120% 80% at 50% 50%, black 40%, transparent 90%);
      opacity: 0.28;
    }

    .vibe-1865 .halo {
      background:
        conic-gradient(from 0deg,
          color-mix(in oklab, var(--acc1) 30%, transparent) 0 20deg,
          transparent 20deg 40deg,
          color-mix(in oklab, var(--acc2) 30%, transparent) 40deg 60deg,
          transparent 60deg 100deg,
          color-mix(in oklab, var(--acc1) 30%, transparent) 100deg 120deg,
          transparent 120deg 360deg);
      filter: blur(20px) saturate(1.1);
      mix-blend-mode: screen;
      opacity: 0.25;
      transform-origin: 50% 50%;
      animation: halo-spin 80s linear infinite;
    }
    @keyframes halo-spin { to { transform: rotate(360deg); } }
    .vibe-1865.paused .halo,
    .vibe-1865.paused .nebula { animation-play-state: paused !important; }

    /* Stage (canvas) */
    .vibe-1865 .stage {
      position: absolute; inset: 0;
    }
    .vibe-1865 canvas {
      width: 100%; height: 100%; display: block;
      filter: saturate(1.05) contrast(1.02);
    }

    /* Control panel */
    .vibe-1865 .panel {
      position: relative; z-index: 2;
      display: grid; gap: 10px;
      max-width: 860px;
      margin: clamp(16px, 3.2vw, 28px);
      padding: clamp(16px, 3.6vw, 32px);
      border-radius: calc(var(--r) - 10px);
      background: color-mix(in oklab, rgba(0,0,0,0.25), transparent 40%);
      backdrop-filter: blur(10px) saturate(1.15);
      border: 1px solid color-mix(in oklab, var(--edge), transparent 20%);
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    }
    .vibe-1865 .eyebrow {
      display: inline-flex; align-items: center; gap: 10px;
      font-size: 11px; letter-spacing: 0.22em; text-transform: uppercase;
      color: var(--muted);
    }
    .vibe-1865 .eyebrow::before {
      content: ""; width: 38px; height: 1px;
      background: linear-gradient(90deg, transparent, var(--muted));
      border-radius: 2px;
    }
    .vibe-1865 .title {
      margin: 2px 0 4px;
      font-weight: 900;
      letter-spacing: -0.02em;
      line-height: 1.02;
      font-size: clamp(32px, 6.6vw, 74px);
    }
    .vibe-1865 .accent {
      background: linear-gradient(90deg, var(--acc1), var(--acc2));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 0 30px var(--glow);
    }
    .vibe-1865 .sub {
      color: color-mix(in oklab, var(--muted) 90%, transparent);
      font-size: clamp(14px, 2.2vw, 18px);
      line-height: 1.65; max-width: 72ch;
      margin: 2px 0 8px;
    }

    .vibe-1865 .controls {
      display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
      margin-top: 4px;
    }
    .vibe-1865 .cta {
      appearance: none; border: 0; cursor: pointer; user-select: none;
      border-radius: 999px;
      padding: 12px 18px;
      font-weight: 900; font-size: 14px; letter-spacing: 0.02em;
      color: #08101a;
      background: linear-gradient(90deg, var(--acc1), var(--acc2));
      box-shadow: 0 12px 28px color-mix(in oklab, var(--acc2), transparent 60%);
      transition: transform 140ms ease, filter 180ms ease, box-shadow 180ms ease;
    }
    .vibe-1865 .cta:hover { transform: translateY(-1px); filter: saturate(1.05); box-shadow: 0 16px 36px color-mix(in oklab, var(--acc1), transparent 50%); }

    .vibe-1865 .seg {
      display: inline-flex; gap: 4px; padding: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .vibe-1865[data-scheme="aurora"] .seg { background: rgba(10,15,30,0.05); border-color: rgba(10,15,30,0.10); }
    .vibe-1865 .seg button {
      appearance: none; border: 0; cursor: pointer;
      padding: 8px 10px; border-radius: 999px;
      background: transparent; color: var(--muted);
      font-size: 12px; font-weight: 800; letter-spacing: 0.06em;
      transition: color 150ms ease, background 150ms ease;
    }
    .vibe-1865 .seg button.active,
    .vibe-1865 .seg button:hover { color: var(--fg); background: rgba(255,255,255,0.12); }

    .vibe-1865 .slider {
      display: inline-flex; align-items: center; gap: 10px;
      padding: 8px 12px; border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--muted);
      font-size: 12px; font-weight: 800; letter-spacing: 0.04em;
    }
    .vibe-1865 input[type="range"] {
      -webkit-appearance: none; appearance: none;
      width: 160px; height: 28px; background: transparent;
    }
    .vibe-1865 input[type="range"]::-webkit-slider-runnable-track,
    .vibe-1865 input[type="range"]::-moz-range-track {
      height: 6px; border-radius: 999px;
      background: linear-gradient(90deg, var(--acc1), var(--acc2));
      opacity: 0.75;
    }
    .vibe-1865 input[type="range"]::-webkit-slider-thumb,
    .vibe-1865 input[type="range"]::-moz-range-thumb {
      -webkit-appearance: none; appearance: none;
      width: 16px; height: 16px; border-radius: 50%;
      background: #fff; border: 2px solid color-mix(in oklab, var(--acc2), var(--acc1) 50%);
      margin-top: -5px; box-shadow: 0 3px 10px rgba(0,0,0,0.25);
    }

    .vibe-1865 .meta {
      margin-top: 8px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center;
      color: var(--muted); font-size: 12px; opacity: 0.95;
    }
    .vibe-1865 .live { display: inline-flex; align-items: center; gap: 8px; }
    .vibe-1865 .dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, var(--acc1), var(--acc2));
      box-shadow: 0 0 0 0 color-mix(in oklab, var(--acc1), transparent 45%);
      animation: pulse-dot-1865 2200ms ease-out infinite;
    }
    @keyframes pulse-dot-1865 {
      0% { box-shadow: 0 0 0 0 color-mix(in oklab, var(--acc1), transparent 45%); }
      70% { box-shadow: 0 0 0 11px transparent; }
      100% { box-shadow: 0 0 0 0 transparent; }
    }

    @media (max-width: 860px) {
      .vibe-1865 .panel { padding: 18px; margin: 14px; }
      .vibe-1865 input[type="range"] { width: 120px; }
    }
  </style>

  <div class="poster" role="region" aria-labelledby="or-title">
    <div class="halo" aria-hidden="true"></div>
    <div class="grid" aria-hidden="true"></div>
    <div class="nebula" aria-hidden="true"></div>
    <div class="stage" role="img" aria-label="Generative orrery with orbiting bodies and trails"><canvas aria-hidden="true"></canvas></div>

    <div class="panel">
      <div class="eyebrow">Vibe Studio · Iteration 1865</div>
      <h1 class="title" id="or-title">
        The Orrery Chamber — <span class="accent">time drawn as circles</span>
      </h1>
      <p class="sub">
        Planets sweep quiet ellipses. Nudge the gravity with your cursor. Press space to still the sky.
      </p>

      <div class="controls">
        <button class="cta" type="button" aria-label="Pulse gravity">Pulse Gravity ⟡</button>

        <div class="seg" role="tablist" aria-label="Scheme">
          <button role="tab" aria-selected="true" class="active" data-scheme="nocturne">Nocturne</button>
          <button role="tab" aria-selected="false" data-scheme="aurora">Aurora</button>
          <button role="tab" aria-selected="false" data-scheme="mono">Mono</button>
        </div>

        <label class="slider" for="tempo">
          Tempo
          <input id="tempo" type="range" min="0" max="100" value="58" aria-label="Tempo">
        </label>
      </div>

      <div class="meta">
        <span class="live"><span class="dot" aria-hidden="true"></span> Live</span>
        <span id="last-updated">Last updated: 2026-01-10 08:27:47 EST</span>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const root = document.currentScript.closest('.vibe-1865');
      const canvas = root.querySelector('canvas');
      const stage = root.querySelector('.stage');
      const schemeButtons = root.querySelectorAll('.seg [data-scheme]');
      const updated = root.querySelector('#last-updated');
      const cta = root.querySelector('.cta');
      const tempo = root.querySelector('#tempo');

      // Last updated
      try {
        const now = new Date();
        const fmt = new Intl.DateTimeFormat(undefined, {
          year: 'numeric', month: 'short', day: '2-digit',
          hour: '2-digit', minute: '2-digit', second: '2-digit',
          hour12: false, timeZoneName: 'short'
        });
        updated.textContent = 'Last updated: ' + fmt.format(now);
      } catch {
        updated.textContent = 'Last updated: ' + new Date().toLocaleString();
      }

      // Theme toggling
      function setScheme(s) {
        root.setAttribute('data-scheme', s);
        schemeButtons.forEach(b => {
          const active = b.getAttribute('data-scheme') === s;
          b.classList.toggle('active', active);
          b.setAttribute('aria-selected', active ? 'true' : 'false');
        });
        readVars(); // refresh palette
      }
      schemeButtons.forEach(b => b.addEventListener('click', () => setScheme(b.getAttribute('data-scheme'))));
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === '1') setScheme('nocturne');
        if (k === '2') setScheme('aurora');
        if (k === '3') setScheme('mono');
      });

      const ctx = canvas.getContext('2d', { alpha: true });
      let dpr = Math.max(1, window.devicePixelRatio || 1);
      let w = 0, h = 0, cx = 0, cy = 0;
      function resize() {
        const r = stage.getBoundingClientRect();
        dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.max(1, Math.floor(r.width * dpr));
        canvas.height = Math.max(1, Math.floor(r.height * dpr));
        canvas.style.width = r.width + 'px';
        canvas.style.height = r.height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        w = r.width; h = r.height; cx = w/2; cy = h/2;
      }
      resize();
      new ResizeObserver(resize).observe(stage);
      window.addEventListener('resize', resize);

      // Palette from CSS variables
      let colors = { acc1: '#81d4ff', acc2: '#a57aff', fadeRGB: '6,9,22', fg: '#eaf1ff' };
      function readVars() {
        const cs = getComputedStyle(root);
        colors = {
          acc1: cs.getPropertyValue('--acc1').trim(),
          acc2: cs.getPropertyValue('--acc2').trim(),
          fadeRGB: cs.getPropertyValue('--fade-rgb').trim(),
          fg: cs.getPropertyValue('--fg').trim(),
        };
      }
      readVars();

      // Utility: mix two hex colors (simple lerp)
      function mix(a, b, t){
        const pa = a.replace('#','');
        const pb = b.replace('#','');
        const ar = parseInt(pa.substring(0,2),16), ag = parseInt(pa.substring(2,4),16), ab = parseInt(pa.substring(4,6),16);
        const br = parseInt(pb.substring(0,2),16), bg = parseInt(pb.substring(2,4),16), bb = parseInt(pb.substring(4,6),16);
        const r = Math.round(ar + (br - ar)*t);
        const g = Math.round(ag + (bg - ag)*t);
        const b2 = Math.round(ab + (bb - ab)*t);
        return `rgb(${r},${g},${b2})`;
      }

      // System
      let raf = null, paused = false;
      let tempoFactor = Number(tempo.value) / 100; // 0..1
      tempo.addEventListener('input', () => { tempoFactor = Number(tempo.value)/100; });

      // Bodies
      const BODIES = [];
      const N = 10;
      function resetBodies(){
        BODIES.length = 0;
        const Rmin = Math.min(w, h) * 0.08;
        const step = Math.min(w, h) * 0.035;
        for (let i = 0; i < N; i++) {
          const r = Rmin + i * step + (i%2 ? 6 : -2);
          const ang = Math.random() * Math.PI * 2;
          const size = Math.max(2, 2 + (i * 0.6));
          const base = 0.001 + (0.0025 * (1 - i/N));
          const speed = base * (0.7 + Math.random()*0.6);
          const tint = mix(colors.acc1, colors.acc2, i / (N-1));
          BODIES.push({ r, ang, speed, size, tint });
        }
      }
      resetBodies();

      // Pointer gravity
      const pointer = { x: cx, y: cy, over: false };
      stage.addEventListener('pointermove', (e) => {
        const r = stage.getBoundingClientRect();
        pointer.x = e.clientX - r.left;
        pointer.y = e.clientY - r.top;
        pointer.over = true;
      });
      stage.addEventListener('pointerleave', () => pointer.over = false);

      // Gravity pulse ripples
      const ripples = [];
      function pulse(px = cx, py = cy) {
        ripples.push({ x: px, y: py, radius: 0, life: 1 });
        // kick angles slightly away from pulse
        for (let i = 0; i < BODIES.length; i++) {
          const b = BODIES[i];
          const bx = cx + Math.cos(b.ang) * b.r;
          const by = cy + Math.sin(b.ang) * b.r;
          const dx = bx - px, dy = by - py;
          const d = Math.hypot(dx, dy) || 1;
          const force = Math.min(1, 180 / d) * (0.8 + tempoFactor);
          b.ang += (Math.random() - 0.5) * 0.2 * force;
        }
        drawPulseRing(px, py); // visual overlay via DOM ripple effect
      }
      function drawPulseRing(px, py){
        const ring = document.createElement('span');
        const ringSize = Math.max(w, h) * 1.4;
        Object.assign(ring.style, {
          position: 'absolute',
          left: (px - ringSize/2) + 'px',
          top: (py - ringSize/2) + 'px',
          width: ringSize + 'px',
          height: ringSize + 'px',
          borderRadius: '50%',
          pointerEvents: 'none',
          mixBlendMode: 'overlay',
          boxShadow: `0 0 0 0 ${colors.acc1}`,
          border: `1px solid ${colors.acc2}`,
          opacity: '0.9',
          transform: 'scale(0.2)',
          transition: 'transform 900ms cubic-bezier(.2,.8,0,1), opacity 1100ms ease'
        });
        stage.appendChild(ring);
        requestAnimationFrame(() => { ring.style.transform = 'scale(1)'; ring.style.opacity = '0'; });
        setTimeout(() => ring.remove(), 1200);
      }

      cta.addEventListener('click', () => pulse(cx, cy));
      stage.addEventListener('click', (e) => {
        const r = stage.getBoundingClientRect();
        pulse(e.clientX - r.left, e.clientY - r.top);
      });

      // Animation
      function setPaused(p){
        paused = p;
        root.classList.toggle('paused', p);
        if (p) { if (raf) cancelAnimationFrame(raf); raf = null; }
        else { if (!raf) raf = requestAnimationFrame(tick); }
      }

      let tPrev = performance.now();
      function tick(now){
        const dt = Math.min(33, now - tPrev); // ms
        tPrev = now;

        // gentle center drift toward pointer
        const targetCX = pointer.over ? (cx + (pointer.x - cx) * 0.07) : cx;
        const targetCY = pointer.over ? (cy + (pointer.y - cy) * 0.07) : cy;

        // Fade trails
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(${colors.fadeRGB}, ${0.08})`;
        ctx.fillRect(0, 0, w, h);

        // Soft center glow
        const g = ctx.createRadialGradient(targetCX, targetCY, 0, targetCX, targetCY, Math.min(w,h)*0.18);
        g.addColorStop(0, 'rgba(255,255,255,0.08)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        // Update and draw bodies
        for (let i = 0; i < BODIES.length; i++) {
          const b = BODIES[i];
          b.ang += b.speed * (0.35 + tempoFactor * 1.8) * (dt / 16.6);

          // Slight ellipse wobble
          const ex = 1 + Math.sin(now * 0.00007 + i) * 0.06;
          const ey = 1 - Math.sin(now * 0.00013 + i*0.5) * 0.05;

          const x = targetCX + Math.cos(b.ang) * b.r * ex;
          const y = targetCY + Math.sin(b.ang) * b.r * ey;

          // Orbit lines (ghost)
          ctx.beginPath();
          ctx.strokeStyle = `rgba(255,255,255,0.06)`;
          ctx.lineWidth = 1;
          ctx.ellipse(targetCX, targetCY, b.r*ex, b.r*ey, 0, 0, Math.PI*2);
          ctx.stroke();

          // Body
          ctx.beginPath();
          ctx.fillStyle = b.tint;
          ctx.shadowColor = b.tint;
          ctx.shadowBlur = 24;
          ctx.arc(x, y, b.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Comet glint
          ctx.beginPath();
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.arc(x - b.size*0.3, y - b.size*0.3, Math.max(0.8, b.size*0.25), 0, Math.PI*2);
          ctx.fill();
        }

        // Ripples bloom (subtle draw)
        for (let i = ripples.length - 1; i >= 0; i--) {
          const rp = ripples[i];
          rp.radius += (0.8 + tempoFactor*2.2) * (dt / 16.6) * 2.0;
          rp.life -= 0.008 * (dt / 16.6);
          if (rp.life <= 0) { ripples.splice(i,1); continue; }
          ctx.beginPath();
          ctx.strokeStyle = `rgba(255,255,255,${0.25 * rp.life})`;
          ctx.lineWidth = 1;
          ctx.arc(rp.x, rp.y, rp.radius, 0, Math.PI*2);
          ctx.stroke();
        }

        raf = requestAnimationFrame(tick);
      }

      // Keyboard controls
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (e.code === 'Space') { e.preventDefault(); setPaused(!paused); }
        if (k === 'p') { pulse(cx, cy); }
        if (k === 'r') { resetBodies(); }
      });

      // Respect reduced motion
      const m = window.matchMedia('(prefers-reduced-motion: reduce)');
      function applyReduced(){
        if (m.matches) setPaused(true);
      }
      m.addEventListener?.('change', applyReduced);
      applyReduced();

      // On theme change, recolor bodies and clear canvas softly
      const clearSoft = () => {
        ctx.clearRect(0,0,w,h);
        resetBodies();
      };
      const mo = new MutationObserver(clearSoft);
      mo.observe(root, { attributes: true, attributeFilter: ['data-scheme'] });

      // Kick off
      setPaused(false);

      // Re-center on resize and rebuild orbits
      window.addEventListener('resize', () => { cx = w/2; cy = h/2; resetBodies(); });
    })();
  </script>
</div>
      </section>
      <!-- END_EDITABLE -->
    <script>
      // Only show a local placeholder if the agent hasn't written a timestamp yet
      const el = document.getElementById('last-updated');
      if (el && (!el.textContent || el.textContent.includes('not yet'))) {
        const now = new Date();
        el.textContent = `Last updated: ${now.toLocaleString(undefined, { hour12: false })}`;
      }
    </script>
  </body>
  </html>


