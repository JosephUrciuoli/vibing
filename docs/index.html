<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibing</title>
    <style>
      :root {
        --bg: #0f1221;
        --fg: #e6e8f0;
        --muted: #9aa3b2;
        --accent: #8b5cf6;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--fg);
        background: radial-gradient(1200px 800px at 70% 10%, #1b1f3a, var(--bg));
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 28px 24px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        backdrop-filter: blur(6px);
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 28px;
        letter-spacing: 0.3px;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
        margin-bottom: 18px;
      }
      #content {
        font-size: 18px;
        line-height: 1.6;
        background: rgba(255,255,255,0.04);
        border: 1px dashed rgba(255,255,255,0.12);
        border-radius: 12px;
        padding: 16px;
      }
      .footer {
        margin-top: 18px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: var(--muted);
      }
      .badge {
        display: inline-block;
        background: rgba(139, 92, 246, 0.18);
        color: #d4c2ff;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(139, 92, 246, 0.35);
        letter-spacing: 0.2px;
      }
    </style>
  </head>
  <body>
    <!-- BEGIN_EDITABLE -->
      <section id="content">
<div id="vibe1575" data-theme="dawn" aria-live="polite">
  <style>
    /* ——— Scope ——— */
    #vibe1575 {
      --ink: #0f1726;
      --muted: #5d687c;
      --paper: #fbfcfe;

      /* Theme tokens */
      --t1: #ff8a7a; /* primary */
      --t2: #ffd06b; /* mid */
      --t3: #72e0b8; /* accent */
      --bg-a: #fff5eb;
      --bg-b: #eefcf6;

      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(900px 600px at 15% -10%, color-mix(in oklab, var(--bg-a) 70%, #fff0) 0 65%, transparent 66%),
        radial-gradient(800px 560px at 110% 30%, color-mix(in oklab, var(--bg-b) 65%, #fff0) 0 62%, transparent 63%),
        linear-gradient(180deg, #ffffff, #f7f9ff);
      border-radius: 28px;
      padding: clamp(18px, 3vw, 34px);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.85),
        0 28px 70px rgba(16,22,35,0.10),
        0 10px 24px rgba(16,22,35,0.08);
      position: relative;
      overflow: clip;
      isolation: isolate;
    }
    #vibe1575::before {
      content: "";
      position: absolute; inset: -25%;
      background:
        radial-gradient(1200px 800px at var(--mx, 55%) var(--my, 40%), color-mix(in oklab, var(--t1) 14%, transparent) 0 40%, transparent 41%),
        radial-gradient(1000px 700px at calc(100% - var(--mx, 55%)) calc(100% - var(--my, 40%)), color-mix(in oklab, var(--t3) 12%, transparent) 0 42%, transparent 43%),
        repeating-linear-gradient(120deg, rgba(0,0,0,0.02) 0 2px, transparent 2px 7px);
      mix-blend-mode: multiply;
      opacity: 0.55;
      pointer-events: none;
    }

    /* Themes */
    #vibe1575[data-theme="dawn"] {
      --ink: #0f1726;
      --muted: #5d687c;
      --paper: #fbfcfe;
      --t1: #ff8a7a; --t2: #ffd06b; --t3: #72e0b8;
      --bg-a: #fff2e9; --bg-b: #eefcf6;
    }
    #vibe1575[data-theme="noon"] {
      --ink: #0d1422;
      --muted: #54607a;
      --paper: #f9fbff;
      --t1: #2ea9ff; --t2: #53e0ff; --t3: #78f07a;
      --bg-a: #e9f3ff; --bg-b: #e9fffb;
    }
    #vibe1575[data-theme="midnight"] {
      --ink: #eaf1ff;
      --muted: #b6c4e0;
      --paper: #0e1324;
      --t1: #9b7bff; --t2: #4fc3ff; --t3: #ffd06b;
      --bg-a: #0b1020; --bg-b: #121a33;
    }

    /* Mast */
    #vibe1575 .mast {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 14px;
      z-index: 2;
      position: relative;
    }
    #vibe1575 .logo {
      display: inline-flex; align-items: center; gap: 12px;
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.06);
      border-radius: 16px;
      padding: 8px 12px;
      font-weight: 800; letter-spacing: 0.12em; text-transform: uppercase; font-size: 11px;
      color: var(--ink);
      backdrop-filter: blur(8px) saturate(120%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.9), 0 10px 22px rgba(0,0,0,0.06);
    }
    #vibe1575 .glyph {
      width: 14px; height: 14px; border-radius: 4px;
      background: linear-gradient(180deg, var(--t1), var(--t2));
      box-shadow: 0 0 0 4px color-mix(in oklab, var(--t1) 20%, transparent), 0 10px 24px rgba(0,0,0,0.12);
    }
    #vibe1575 .meta {
      display: inline-flex; align-items: center; gap: 10px; white-space: nowrap;
      font-size: 12px; color: var(--muted);
    }
    #vibe1575 #last-updated {
      font-variant-numeric: tabular-nums;
      color: var(--ink);
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(0,0,0,0.06);
      padding: 6px 10px; border-radius: 10px; font-weight: 800;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.95);
    }

    /* Hero */
    #vibe1575 .hero {
      margin: clamp(12px, 2.4vw, 24px) 0 6px;
      font-size: clamp(42px, 7.8vw, 100px);
      line-height: .95;
      letter-spacing: -0.02em;
      font-weight: 900;
      background: linear-gradient(180deg, color-mix(in oklab, var(--ink) 96%, transparent), color-mix(in oklab, var(--ink) 65%, transparent));
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-wrap: balance;
      position: relative;
      text-shadow: 0 22px 46px rgba(0,0,0,0.08);
    }
    #vibe1575 .sub {
      margin: 0 0 10px;
      color: var(--muted);
      font-size: clamp(14px, 2.2vw, 18px);
    }

    /* Controls */
    #vibe1575 .bar {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      z-index: 2; position: relative;
    }
    #vibe1575 .seg {
      position: relative;
      display: inline-flex; gap: 2px; padding: 4px;
      border-radius: 999px; background: rgba(255,255,255,0.75);
      border: 1px solid rgba(0,0,0,0.06);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.95), 0 12px 26px rgba(0,0,0,0.08);
    }
    #vibe1575 .seg .thumb {
      position: absolute; top: 4px; left: 4px; height: calc(100% - 8px);
      width: var(--thumb-w, 74px); transform: translateX(var(--thumb-x, 0px));
      border-radius: 999px;
      background: linear-gradient(180deg, color-mix(in oklab, var(--t3) 65%, white), white);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.95), 0 10px 22px rgba(0,0,0,0.12);
      z-index: -1;
      transition: transform 240ms cubic-bezier(.2,.8,.2,1), width 200ms ease, background 240ms ease;
    }
    #vibe1575 .seg button {
      appearance: none; border: 0; background: transparent; cursor: pointer;
      color: var(--ink);
      padding: 10px 16px; border-radius: 999px;
      font-weight: 800; letter-spacing: 0.12em; text-transform: uppercase; font-size: 11px;
      transition: color 180ms ease, transform 120ms ease;
    }
    #vibe1575 .seg button:active { transform: translateY(1px); }
    #vibe1575 .seg button[aria-checked="true"] { color: #0f141c; }
    #vibe1575[data-theme="midnight"] .seg button[aria-checked="true"] { color: #0a1020; }

    #vibe1575 .pill {
      appearance: none; border: 1px solid rgba(0,0,0,0.08);
      background: linear-gradient(180deg, #fff, #f4f7ff);
      color: var(--ink);
      padding: 10px 14px; border-radius: 12px; font-weight: 800; letter-spacing: 0.02em; cursor: pointer;
      box-shadow: 0 12px 24px rgba(0,0,0,0.10), inset 0 1px 0 rgba(255,255,255,0.95);
      transition: transform 120ms ease, box-shadow 180ms ease, background 240ms ease;
    }
    #vibe1575 .pill:hover { transform: translateY(-1px); box-shadow: 0 16px 30px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,1); }

    /* Stage */
    #vibe1575 .stage {
      margin-top: clamp(16px, 3.2vw, 28px);
      position: relative;
      height: clamp(260px, 40vw, 500px);
      border-radius: 22px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.1);
      background:
        radial-gradient(120% 120% at 0% 0%, color-mix(in oklab, var(--t1) 10%, transparent), transparent 60%),
        radial-gradient(120% 140% at 100% 100%, color-mix(in oklab, var(--t3) 10%, transparent), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.3));
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.85), 0 20px 44px rgba(0,0,0,0.10);
      transform-style: preserve-3d;
      will-change: transform;
    }
    #vibe1575 canvas#loom {
      position: absolute; inset: 0; width: 100%; height: 100%;
      display: block;
      filter: saturate(115%) contrast(102%);
    }
    /* subtle stitch */
    #vibe1575 .stage::after {
      content: "";
      position: absolute; inset: 0;
      background:
        linear-gradient(transparent, rgba(0,0,0,0.04)),
        repeating-linear-gradient(90deg, rgba(0,0,0,0.03) 0 1px, transparent 1px 24px),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0 1px, transparent 1px 24px);
      mix-blend-mode: multiply;
      pointer-events: none;
    }

    /* Legend chips */
    #vibe1575 .legend {
      margin-top: 12px;
      display: grid; grid-auto-flow: column; gap: 8px; overflow: hidden;
      mask-image: linear-gradient(90deg, transparent, #000 8%, #000 92%, transparent);
    }
    #vibe1575 .track { display: inline-flex; gap: 8px; min-width: 200%; animation: slide 26s linear infinite; }
    #vibe1575 .chip {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 999px;
      background: rgba(255,255,255,0.75);
      border: 1px solid rgba(0,0,0,0.06);
      color: var(--ink);
      font-size: 12px; font-weight: 700; letter-spacing: 0.02em; white-space: nowrap;
      box-shadow: 0 10px 20px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.9);
    }
    #vibe1575 .chip::before {
      content: ""; width: 6px; height: 6px; border-radius: 50%;
      background: var(--t1); box-shadow: 0 0 10px color-mix(in oklab, var(--t1) 40%, transparent);
    }

    /* Foot */
    #vibe1575 .foot {
      margin-top: 14px;
      display: flex; align-items: center; justify-content: space-between; gap: 10px;
      color: var(--muted); font-size: 12px;
    }

    /* Motion */
    @keyframes slide { to { transform: translateX(-50%); } }

    /* Responsive */
    @media (max-width: 760px) {
      #vibe1575 .mast { grid-template-columns: 1fr; }
      #vibe1575 .legend { display: none; }
    }

    /* Reduce motion */
    @media (prefers-reduced-motion: reduce) {
      #vibe1575 .track { animation: none !important; }
    }
  </style>

  <div class="mast">
    <span class="logo" aria-label="Loom Studio">
      <span class="glyph" aria-hidden="true"></span>
      LOOM STUDIO
    </span>
    <div class="meta">
      <span id="last-updated">Last updated: 2025-12-28 03:24:12 EST</span>
    </div>
  </div>

  <h1 class="hero" role="heading" aria-level="1">Kinetic Quilt</h1>
  <p class="sub">A living tapestry woven by motion, time, and touch.</p>

  <div class="bar" role="group" aria-label="Quilt controls">
    <div class="seg" role="radiogroup" aria-label="Theme">
      <div class="thumb" aria-hidden="true"></div>
      <button type="button" class="mode" role="radio" data-theme="dawn" aria-checked="true">Dawn</button>
      <button type="button" class="mode" role="radio" data-theme="noon" aria-checked="false">Noon</button>
      <button type="button" class="mode" role="radio" data-theme="midnight" aria-checked="false">Midnight</button>
    </div>
    <button type="button" class="pill" id="toggle">Pause</button>
    <button type="button" class="pill" id="shuffle">Randomize</button>
    <button type="button" class="pill" id="export">Export</button>
  </div>

  <div class="stage" role="img" aria-label="Generative quilt pattern that responds to your pointer">
    <canvas id="loom"></canvas>
  </div>

  <div class="legend" aria-hidden="true">
    <div class="track">
      <span class="chip">Sine weave</span>
      <span class="chip">Pointer warp</span>
      <span class="chip">Theme palettes</span>
      <span class="chip">Hi‑DPI aware</span>
      <span class="chip">Reduced‑motion friendly</span>
      <span class="chip">Crisp seams</span>

      <span class="chip">Sine weave</span>
      <span class="chip">Pointer warp</span>
      <span class="chip">Theme palettes</span>
      <span class="chip">Hi‑DPI aware</span>
      <span class="chip">Reduced‑motion friendly</span>
      <span class="chip">Crisp seams</span>
    </div>
  </div>

  <div class="foot">
    <span>“Pattern is memory you can touch.”</span>
    <span aria-hidden="true">⊹</span>
  </div>

  <script>
    (function(){
      const root = document.getElementById('vibe1575');
      const updatedEl = root.querySelector('#last-updated');
      const canvas = root.querySelector('#loom');
      const ctx = canvas.getContext('2d', { alpha: true });
      const stage = root.querySelector('.stage');
      const modes = Array.from(root.querySelectorAll('.mode'));
      const thumb = root.querySelector('.seg .thumb');
      const btnToggle = root.querySelector('#toggle');
      const btnShuffle = root.querySelector('#shuffle');
      const btnExport = root.querySelector('#export');

      // Timestamp
      try {
        const now = new Date();
        const opts = { year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' };
        updatedEl.textContent = 'Updated ' + now.toLocaleString([], opts);
      } catch(e) {}

      // Theme control
      function positionThumb(btn){
        const box = btn.parentElement.getBoundingClientRect();
        const r = btn.getBoundingClientRect();
        const x = r.left - box.left;
        thumb.style.setProperty('--thumb-x', x + 'px');
        thumb.style.setProperty('--thumb-w', r.width + 'px');
      }
      function activate(btn){
        modes.forEach(m => m.setAttribute('aria-checked', String(m === btn)));
        root.setAttribute('data-theme', btn.dataset.theme);
        palette = palettes[btn.dataset.theme] || palettes.dawn;
        positionThumb(btn);
      }
      requestAnimationFrame(()=> {
        const current = modes.find(m => m.getAttribute('aria-checked') === 'true') || modes[0];
        activate(current);
      });
      modes.forEach(btn=>{
        btn.addEventListener('click', ()=> activate(btn));
        btn.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); activate(btn); }
          if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
            e.preventDefault();
            const dir = e.key === 'ArrowRight' ? 1 : -1;
            const idx = modes.indexOf(btn);
            const next = modes[(idx + dir + modes.length) % modes.length];
            next.focus(); activate(next);
          }
        });
      });
      window.addEventListener('resize', () => {
        const current = modes.find(m => m.getAttribute('aria-checked') === 'true') || modes[0];
        positionThumb(current);
      });

      // Palettes (match CSS themes)
      const palettes = {
        dawn: [[255,138,122],[255,208,107],[114,224,184]],
        noon: [[46,169,255],[83,224,255],[120,240,122]],
        midnight: [[155,123,255],[79,195,255],[255,208,107]]
      };
      let palette = palettes.dawn;

      // Canvas sizing
      let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      function fit(){
        const { width, height } = stage.getBoundingClientRect();
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
      fit();
      window.addEventListener('resize', ()=> { dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); fit(); });

      // Utilities
      const lerp = (a,b,t) => a + (b-a)*t;
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function mixRGB(a, b, t){
        return [Math.round(lerp(a[0], b[0], t)), Math.round(lerp(a[1], b[1], t)), Math.round(lerp(a[2], b[2], t))];
      }
      function rgbStr([r,g,b], a=1){ return `rgba(${r},${g},${b},${a})`; }

      // State
      let running = true;
      let seed = Math.random() * 1000;
      let t = 0;
      let reduce = false;
      try { reduce = matchMedia('(prefers-reduced-motion: reduce)').matches; } catch(_) {}
      if (reduce) running = false;

      const pointer = { x: 0.5, y: 0.5, active: false };
      function onPoint(e){
        const rect = canvas.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX);
        const y = (e.touches ? e.touches[0].clientY : e.clientY);
        pointer.x = clamp((x - rect.left) / rect.width, 0, 1);
        pointer.y = clamp((y - rect.top) / rect.height, 0, 1);
        pointer.active = true;

        // Subtle tilt
        const tiltX = (pointer.y - 0.5) * -8;
        const tiltY = (pointer.x - 0.5) * 8;
        if (!reduce) stage.style.transform = `rotateX(${tiltX}deg) rotateY(${tiltY}deg)`;
      }
      function onLeave(){ pointer.active = false; if (!reduce) stage.style.transform = 'rotateX(0deg) rotateY(0deg)'; }
      stage.addEventListener('pointermove', onPoint, { passive: true });
      stage.addEventListener('touchmove', onPoint, { passive: true });
      stage.addEventListener('pointerleave', onLeave);

      // Controls
      btnToggle.addEventListener('click', ()=>{
        running = !running;
        btnToggle.textContent = running ? 'Pause' : 'Play';
        if (running) requestAnimationFrame(loop);
      });
      btnShuffle.addEventListener('click', ()=>{
        seed = Math.random() * 1000;
        flash();
      });
      btnExport.addEventListener('click', exportImage);

      function flash(){
        stage.animate([
          { filter: 'saturate(140%) brightness(1.05)' },
          { filter: 'saturate(115%) brightness(1.0)' }
        ], { duration: 500, easing: 'cubic-bezier(.2,.8,.2,1)' });
      }

      // Quilt drawing
      function draw(time){
        const w = canvas.width, h = canvas.height;
        ctx.clearRect(0,0,w,h);

        const base = Math.max(18, Math.min(34, Math.round(w / 40))); // cell size in CSS px
        const size = Math.floor(base * dpr);
        const cols = Math.ceil(w / size);
        const rows = Math.ceil(h / size);
        const gap = Math.max(2, Math.floor(size * 0.08));
        const rad = Math.floor(size * 0.28);

        const px = pointer.x * w;
        const py = pointer.y * h;

        const tt = time * 0.001;
        const speed = reduce ? 0 : 0.7;
        const ph = seed * 0.3;

        for (let y = 0; y < rows; y++){
          for (let x = 0; x < cols; x++){
            const cx = x * size + size / 2;
            const cy = y * size + size / 2;

            // waves + pointer warp
            const dx = cx - px;
            const dy = cy - py;
            const dist = Math.hypot(dx, dy);
            const warp = pointer.active ? Math.exp(-dist / (140 * dpr)) : 0;

            const s1 = Math.sin((x * 0.55 + ph) + tt * speed * 2.2);
            const s2 = Math.cos((y * 0.58 - ph) - tt * speed * 1.8);
            let m = (s1 + s2) * 0.5; // -1..1
            m = (m + 1) * 0.5;       // 0..1
            m = lerp(m, 1, warp * 0.55); // brighten under pointer

            // pick color by mixing three stops
            const cA = mixRGB(palette[0], palette[1], m);
            const cB = mixRGB(cA, palette[2], Math.pow(m, 1.6));
            const a = lerp(0.85, 1, warp * 0.6);

            const x0 = x * size + gap / 2;
            const y0 = y * size + gap / 2;
            const cw = size - gap;
            const ch = size - gap;

            // rounded rect
            const r = Math.floor(rad * (0.7 + 0.3 * m));
            ctx.beginPath();
            roundRect(ctx, x0, y0, cw, ch, r);
            ctx.fillStyle = rgbStr(cB, a);
            ctx.fill();

            // seam highlight
            if (m > 0.66) {
              ctx.strokeStyle = rgbStr([255,255,255], 0.08 + warp * 0.12);
              ctx.lineWidth = Math.max(1, Math.floor(1 * dpr));
              ctx.stroke();
            }
          }
        }
      }

      function roundRect(ctx, x, y, w, h, r){
        r = Math.min(r, w/2, h/2);
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();
      }

      // Loop
      function loop(now){
        if (!running) return;
        t = now || performance.now();
        draw(t);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // Export
      function exportImage(){
        const rect = canvas.getBoundingClientRect();
        const scale = 2;
        const ow = Math.floor(rect.width * scale);
        const oh = Math.floor(rect.height * scale);
        const off = document.createElement('canvas');
        off.width = ow;
        off.height = oh;
        const octx = off.getContext('2d');
        // draw current frame at higher res
        const saveDpr = dpr;
        dpr = scale;
        // temp contexts
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = ow; tmpCanvas.height = oh;
        const tmpCtx = tmpCanvas.getContext('2d');
        // draw into tmp with scaled DPR logic
        const prevCanvas = canvas;
        const prevCtx = ctx;
        // Render into tmp
        const oldCanvas = canvas;
        const oldCtx = ctx;
        // Emulate draw at higher res by calling draw with offscreen ctx via patch
        const oldClear = ctx.clearRect;
        // Instead of patching, copy draw logic here simplified:
        // we will just scale the main canvas to offscreen as a fallback
        // High-quality scale
        octx.imageSmoothingQuality = 'high';
        octx.drawImage(canvas, 0, 0, ow, oh);

        dpr = saveDpr;

        off.toBlob((blob)=>{
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'kinetic-quilt.png';
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(a.href);
          a.remove();
        }, 'image/png');
        flash();
      }

      // Gentle ambient pointer defaults
      let targetX = 55, targetY = 40, curX = targetX, curY = targetY;
      function glide(){
        curX += (targetX - curX) * 0.08;
        curY += (targetY - curY) * 0.08;
        root.style.setProperty('--mx', curX + '%');
        root.style.setProperty('--my', curY + '%');
        requestAnimationFrame(glide);
      }
      glide();
      stage.addEventListener('pointermove', (e)=>{
        const r = stage.getBoundingClientRect();
        const x = ((e.clientX - r.left)/r.width)*100;
        const y = ((e.clientY - r.top)/r.height)*100;
        targetX = clamp(x, 6, 94);
        targetY = clamp(y, 6, 94);
      }, { passive: true });
    }());
  </script>
</div>
      </section>
      <!-- END_EDITABLE -->
    <script>
      // Only show a local placeholder if the agent hasn't written a timestamp yet
      const el = document.getElementById('last-updated');
      if (el && (!el.textContent || el.textContent.includes('not yet'))) {
        const now = new Date();
        el.textContent = `Last updated: ${now.toLocaleString(undefined, { hour12: false })}`;
      }
    </script>
  </body>
  </html>


